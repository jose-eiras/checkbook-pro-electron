<script>
        /*******************************************************DASHBOARD PAGE*********************************************************************/

        async function updateDashboard() {
            if (!currentCheckbookId) return;

            try {
                showLoading('dashboard-page');
                
                const [balances, transactions] = await Promise.all([
                    loadBalances(currentCheckbookId),
                    loadTransactions(currentCheckbookId)
                ]);

                // Update balance cards
                updateBalanceCards(balances);
                
                // Update recent transactions table
                updateRecentTransactions(transactions.slice(0, 5));
                
                hideLoading('dashboard-page');
            } catch (error) {
                console.error('Failed to update dashboard:', error);
                hideLoading('dashboard-page');
            }
        }

        function updateBalanceCards(balances) {
            // Update MTD card
            const mtdIncome = document.getElementById('mtd-income');
            const mtdExpenses = document.getElementById('mtd-expenses');
            const mtdNet = document.getElementById('mtd-net');
            
            if (mtdIncome) mtdIncome.textContent = formatCurrency(balances.mtdIncome || 0);
            if (mtdExpenses) mtdExpenses.textContent = formatCurrency(balances.mtdExpenses || 0);
            if (mtdNet) {
                const net = (balances.mtdIncome || 0) - (balances.mtdExpenses || 0);
                mtdNet.textContent = formatCurrency(net);
                mtdNet.className = `font-bold ${net >= 0 ? 'text-banking-green' : 'text-banking-red'}`;
            }

            // Update YTD card
            const ytdIncome = document.getElementById('ytd-income');
            const ytdExpenses = document.getElementById('ytd-expenses');
            const ytdNet = document.getElementById('ytd-net');        
            
            if (ytdIncome) ytdIncome.textContent = formatCurrency(balances.ytdIncome || 0);
            if (ytdExpenses) ytdExpenses.textContent = formatCurrency(balances.ytdExpenses || 0);
            if (ytdNet) {
                const net = (balances.ytdIncome || 0) - (balances.ytdExpenses || 0);
                ytdNet.textContent = formatCurrency(net);
                ytdNet.className = `font-bold ${net >= 0 ? 'text-banking-green' : 'text-banking-red'}`;
            }
        }

        function updateRecentTransactions(transactions) {
            const tbody = document.querySelector('#recent-transactions-table tbody');
            if (!tbody) return;

            if (transactions.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="5" style="text-align: center; padding: 2rem; color: #6b7280;">
                            No transactions found
                        </td>
                    </tr>
                `;
                return;
            }

            tbody.innerHTML = transactions.map(transaction => {
                const amount = parseFloat(transaction.amount) || 0;
                
                // Simple debit/credit logic for Recent Transactions
                // Credit = positive (green), Debit = negative (red)
                const isCredit = transaction.transaction_type === 'credit';
                const displayAmount = isCredit ? amount : -amount;
                const amountColor = isCredit ? 'var(--banking-green)' : 'var(--banking-red)';
                
                return `
                    <tr style="border-bottom: 1px solid #f3f4f6;">
                        <td style="padding: 0.75rem; font-size: 0.875rem;">${formatDate(transaction.transaction_date)}</td>
                        <td style="padding: 0.75rem; font-size: 0.875rem;">${transaction.from_account_name || getAccountName(transaction.from_account_id) || 'Unknown'}</td>
                        <td style="padding: 0.75rem; font-size: 0.875rem; color: var(--banking-blue);">${transaction.to_account_name || getAccountName(transaction.to_account_id) || '-'}</td>
                        <td style="padding: 0.75rem; font-size: 0.875rem;">${transaction.description || transaction.reference_number || '-'}</td>
                        <td style="padding: 0.75rem; text-align: right; font-weight: 600; color: ${amountColor};">
                            ${displayAmount < 0 ? '-' : '+'}${formatCurrency(Math.abs(displayAmount))}
                        </td>
                    </tr>
                `;
            }).join('');
        }

        /**************************************************************ASSETS & LIABILITIES PAGE*******************************************************************/

        async function updateAssetsLiabilities() {
            if (!currentCheckbookId) return;

            try {
                showLoading('assets-liabilities-page');
                
                const accounts = await getAccountsFromCache();

                const assets = accounts.filter(acc => acc.account_type === 'asset');
                const liabilities = accounts.filter(acc => acc.account_type === 'liability');

                updateAccountCards('assets', assets);
                updateAccountCards('liabilities', liabilities);
                
                hideLoading('assets-liabilities-page');
            } catch (error) {
                console.error('Failed to update assets/liabilities:', error);
                hideLoading('assets-liabilities-page');
            }
        }

        function updateAccountCards(type, accounts) {
            // Filter out parent accounts - only show leaf accounts for data entry
            const leafAccounts = accounts.filter(account => {
                // Check if this account has children
                const hasChildren = accounts.some(otherAccount => 
                    otherAccount.parent_code === account.account_code
                );
                // Only show accounts that don't have children (leaf accounts)
                return !hasChildren;
            });
            
            const assetsContainer = document.querySelector(`#assets-liabilities-page .assets-section .account-grid`);
            const liabilitiesContainer = document.querySelector(`#assets-liabilities-page .liabilities-section .account-grid`);
            
            if (type === 'assets' && assetsContainer) {
                assetsContainer.innerHTML = leafAccounts.map(account => `
                    <div class="account-card">
                        <!-- Account Icon -->
                        <div class="account-icon">
                            ${getAccountIcon(account.account_name, account.account_type)}
                        </div>
                        
                        <!-- Account Info with Balance on same row -->
                        <div class="account-info" style="flex: 1;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div class="account-name">${account.account_name}</div>
                                <div class="account-balance-amount" style="color: var(--banking-green); font-weight: 600;">
                                    ${formatCurrency((account.account_balance || 0) + (account.opening_balance || 0))}
                                </div>
                            </div>
                            
                            <!-- Action Buttons on second row -->
                            <div style="display: flex; gap: 0.5rem; margin-top: 0.75rem;">
                                <button class="btn btn-secondary" style="flex: 1; padding: 0.5rem; font-size: 0.875rem;" onclick="openTransactionListModal('${account.id}')" title="Transaction Management">ðŸ“‹ Transactions</button>
                                <button class="btn btn-success" style="flex: 1; padding: 0.5rem; font-size: 0.875rem;" onclick="openReconcileModal('${account.id}')" title="Reconcile">âœ“ Reconcile</button>
                            </div>
                        </div>
                    </div>
                `).join('');
            }
            
            if (type === 'liabilities' && liabilitiesContainer) {
                liabilitiesContainer.innerHTML = leafAccounts.map(account => `
                    <div class="account-card">
                        <!-- Account Icon -->
                        <div class="account-icon">
                            ${getAccountIcon(account.account_name, account.account_type)}
                        </div>
                        
                        <!-- Account Info with Balance on same row -->
                        <div class="account-info" style="flex: 1;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div class="account-name">${account.account_name}</div>
                                <div class="account-balance-amount" style="color: var(--banking-red); font-weight: 600;">
                                    ${formatCurrency(Math.abs((account.account_balance || 0) + (account.opening_balance || 0)))}
                                </div>
                            </div>
                            
                            <!-- Action Buttons on second row -->
                            <div style="display: flex; gap: 0.5rem; margin-top: 0.75rem;">
                                <button class="btn btn-secondary" style="flex: 1; padding: 0.5rem; font-size: 0.875rem;" onclick="openTransactionListModal('${account.id}')" title="Transaction Management">ðŸ“‹ Transactions</button>
                                <button class="btn btn-success" style="flex: 1; padding: 0.5rem; font-size: 0.875rem;" onclick="openReconcileModal('${account.id}')" title="Reconcile">âœ“ Reconcile</button>
                            </div>
                        </div>
                    </div>
                `).join('');
            }
        }

        /***************************************************************************TRANSACTIONS PAGE********************************************************************/
        async function updateTransactions() {

            console.log('Passei por aqui... ', '2320');

            const accounts = await Promise.all([
                getAccountsFromCache()
            ]);

            if(noFilter === false) {
                // Populate account dropdown for transaction detail filter
                populateTransactionDetailAccountFilter(accounts);
            }
            
            // Load Transaction Detail with "This Year" filter (now the default)
            await updateTransactionDetailPeriod();
        }

        /***********************************************************************MODALS******************************************************************/

        // Modal population functions
        async function populateAddTransactionModal(account, hasPresetAccount = false) {
            // console.log('populateAddTransactionModal called with:', { account, hasPresetAccount });
            
            const modal = document.getElementById('add-transaction-modal');
            if (!modal) {
                console.error('Add transaction modal not found');
                return;
            }
            
            // Reset form completely when opening modal
            const form = modal.querySelector('form');
            if (form) {
                form.reset();
                // Set today's date as default
                const dateField = form.querySelector('[name="date"]');
                if (dateField) {
                    const today = new Date();
                    const year = today.getFullYear();
                    const month = String(today.getMonth() + 1).padStart(2, '0');
                    const day = String(today.getDate()).padStart(2, '0');
                    dateField.value = `${year}-${month}-${day}`;
                }
            }
            
            // Clear any data attributes to ensure fresh state
            modal.removeAttribute('data-account-id');
            modal.removeAttribute('data-return-account-id');
            modal.removeAttribute('data-return-source');
            
            const fromAccountInfo = modal.querySelector('#from-account-info');
            const fromAccountSelector = modal.querySelector('#from-account-selector');
            
            // console.log('Found elements:', { fromAccountInfo, fromAccountSelector });
            
            if (hasPresetAccount && account && account.data) {
                // Opened from account card - show account info header, hide from account selector
                // console.log('Showing preset account info');
                const accountData = account.data;
                
                fromAccountInfo.style.display = 'block';
                fromAccountSelector.style.display = 'none';
                
                // Update account info in the header
                const infoValues = fromAccountInfo.querySelectorAll('.info-value');
                if (infoValues[0]) {
                    infoValues[0].textContent = accountData.account_name || 'Unknown Account';
                }
                if (infoValues[1]) {
                    infoValues[1].textContent = formatCurrency((accountData.account_balance || 0) + (accountData.opening_balance || 0));
                }
                
                // Store account ID for form submission
                modal.setAttribute('data-account-id', accountData.id);
            } else {
                // Opened from Transactions page - show from account selector, hide account info header
                // console.log('Showing from account selector');
                if (fromAccountInfo) {
                    fromAccountInfo.style.display = 'none';
                    fromAccountInfo.style.setProperty('display', 'none', 'important');
                }
                if (fromAccountSelector) {
                    fromAccountSelector.style.display = 'block';
                    fromAccountSelector.style.setProperty('display', 'block', 'important');
                    // console.log('Set fromAccountSelector display to block with !important');
                } else {
                    console.error('fromAccountSelector element not found!');
                }
                
                // Clear any stored account ID
                modal.removeAttribute('data-account-id');
            }
            
            // Set today's date as default
            const dateField = modal.querySelector('[name="date"]');
            if (dateField) {
                const today = new Date();
                const year = today.getFullYear();
                const month = String(today.getMonth() + 1).padStart(2, '0');
                const day = String(today.getDate()).padStart(2, '0');
                dateField.value = `${year}-${month}-${day}`;
            }
            
            // Populate account dropdowns with real data
            await populateAccountSelects(modal);
        }

        function populateTransactionListModal(account, transactions) {
            if (!account || !account.data) return;
            
            // Extract the actual account data from the API response
            const accountData = account.data;
            
            const modal = document.getElementById('list-transactions-modal');
            if (modal) {
                // Update account details
                const infoItems = modal.querySelectorAll('.info-value');
                if (infoItems[0]) infoItems[0].textContent = accountData.account_name || 'Unknown Account';
                if (infoItems[1]) infoItems[1].textContent = accountData.account_type || 'Unknown';
                if (infoItems[2]) infoItems[2].textContent = formatCurrency((accountData.account_balance || 0) + (accountData.opening_balance || 0));
                if (infoItems[3]) infoItems[3].textContent = accountData.account_code || 'N/A';
                
                // Update transaction table
                const tbody = modal.querySelector('.table tbody');
                if (tbody) {
                    if (transactions.length === 0) {
                        tbody.innerHTML = `
                            <tr>
                                <td colspan="7" style="text-align: center; padding: 2rem; color: #6b7280;">
                                    No transactions found for this account
                                </td>
                            </tr>
                        `;
                    } else {
                        // Filter to only show unreconciled transactions
                        const unreconciledTransactions = transactions.filter(t => !t.is_reconciled);
                        
                        tbody.innerHTML = unreconciledTransactions.map(transaction => `
                            <tr>
                                <td>${formatDate(transaction.transaction_date)}</td>
                                <td>${transaction.to_account_name || getAccountName(transaction.to_account_id) || 'Unknown'}</td>
                                <td>${transaction.reference_number || '-'}</td>
                                <td>${transaction.description || '-'}</td>
                                <td style="color: ${transaction.transaction_type === 'credit' ? 'var(--banking-green)' : 'var(--banking-red)'};">
                                    ${transaction.transaction_type === 'credit' ? '+' : '-'}${formatCurrency(Math.abs(transaction.amount))}
                                </td>
                                <td><span class="badge ${transaction.is_reconciled ? 'badge-success' : 'badge-warning'}">${transaction.is_reconciled ? 'Cleared' : 'Pending'}</span></td>
                                <td style="display: flex; gap: 0.5rem;">
                                    <button class="btn btn-secondary" style="padding: 0.25rem 0.5rem; font-size: 0.75rem;" onclick="editTransaction('${transaction.id}')">Edit</button>
                                    <button class="btn btn-danger" style="padding: 0.25rem 0.5rem; font-size: 0.75rem;" onclick="deleteTransaction('${transaction.id}')">Delete</button>
                                </td>
                            </tr>
                        `).join('');
                    }
                }
            }
        }

        async function populateReconcileModal(account, transactions) {
            if (!account) return;
            
            // Store account data globally for calculations
            window.currentReconcileAccount = account;
            
            // Handle both wrapped and unwrapped account objects
            const accountData = account.data || account;
            
            const modal = document.getElementById('reconcile-modal');
            if (!modal) {
                console.error('Reconcile modal not found');
                return;
            }
            
            try {
                // Update account details
                const infoItems = modal.querySelectorAll('.info-value');
                const pendingTransactions = transactions.filter(t => !t.is_reconciled);
                
                if (infoItems[0]) infoItems[0].textContent = accountData.account_name || 'Unknown Account';
                if (infoItems[1]) infoItems[1].textContent = formatCurrency((accountData.account_balance || 0) + (accountData.opening_balance || 0));
                if (infoItems[2]) infoItems[2].textContent = pendingTransactions.length.toString();
                
                // Update status badge
                const statusBadge = modal.querySelector('.badge');
                if (statusBadge) {
                    if (pendingTransactions.length === 0) {
                        statusBadge.textContent = 'Balanced';
                        statusBadge.className = 'badge badge-success';
                    } else {
                        statusBadge.textContent = 'Unbalanced';
                        statusBadge.className = 'badge badge-warning';
                    }
                }
                
                // Load and update last reconciliation info with real data
                try {
                    const accountId = accountData.id;
                    const reconciliations = await loadReconciliationsByAccount(accountId);
                    
                    // Find the most recent reconciliation by comparing dates
                    let lastReconciliation = null;
                    if (reconciliations.length > 0) {
                        lastReconciliation = reconciliations.reduce((latest, current) => {
                            const latestDate = new Date(latest.statement_date);
                            const currentDate = new Date(current.statement_date);
                            return currentDate > latestDate ? current : latest;
                        });
                    }
                    
                    // Target the specific last reconciliation elements directly by ID
                    const lastStatementDateEl = modal.querySelector('#last-statement-Date');
                    const lastStatementBalanceEl = modal.querySelector('#liabilities-section'); // This is misnamed but that's the actual ID
                    
                    if (lastReconciliation) {
                        const formattedDate = formatDate(lastReconciliation.statement_date);
                        const formattedBalance = formatCurrency(lastReconciliation.statement_balance);
                        
                        if (lastStatementDateEl) lastStatementDateEl.textContent = formattedDate;
                        if (lastStatementBalanceEl) lastStatementBalanceEl.textContent = formattedBalance;
                        
                        // Pre-populate the new statement balance field with the last statement balance
                        const statementBalanceInput = modal.querySelector('[name="statementBalance"]');
                        if (statementBalanceInput) {
                            statementBalanceInput.value = lastReconciliation.statement_balance.toFixed(2);
                        }
                    } else {
                        if (lastStatementDateEl) lastStatementDateEl.textContent = 'No previous reconciliation';
                        if (lastStatementBalanceEl) lastStatementBalanceEl.textContent = '$0.00';
                        
                        // For first reconciliation, start with current account balance
                        const statementBalanceInput = modal.querySelector('[name="statementBalance"]');
                        if (statementBalanceInput) {
                            const currentBalance = (accountData.account_balance || 0) + (accountData.opening_balance || 0);
                            statementBalanceInput.value = currentBalance.toFixed(2);
                        }
                    }
                } catch (error) {
                    console.error('Error loading reconciliation history:', error);
                    // Fall back to placeholder text if loading fails
                    const lastStatementDateEl = modal.querySelector('#last-statement-Date');
                    const lastStatementBalanceEl = modal.querySelector('#liabilities-section');
                    if (lastStatementDateEl) lastStatementDateEl.textContent = 'Unable to load history';
                    if (lastStatementBalanceEl) lastStatementBalanceEl.textContent = '$0.00';
                }
                
                // Clear form fields
                const form = modal.querySelector('form');
                if (form) {
                    form.reset();
                    // Set today's date as default
                    const dateField = form.querySelector('[name="statementDate"]');
                    if (dateField) {
                        const today = new Date();
                        const year = today.getFullYear();
                        const month = String(today.getMonth() + 1).padStart(2, '0');
                        const day = String(today.getDate()).padStart(2, '0');
                        dateField.value = `${year}-${month}-${day}`;
                    }
                }
                
                // Update transaction table for reconciliation
                const tbody = modal.querySelector('.table tbody');
                if (tbody) {
                    if (pendingTransactions.length === 0) {
                        tbody.innerHTML = `
                            <tr>
                                <td colspan="7" style="text-align: center; padding: 2rem; color: #6b7280;">
                                    All transactions have been reconciled
                                </td>
                            </tr>
                        `;
                    } else {
                        tbody.innerHTML = pendingTransactions.map(transaction => `
                            <tr>
                                <td>
                                    <input type="checkbox" class="checkbox" onchange="updateReconcileBalance()" data-transaction-id="${transaction.id}" data-amount="${transaction.amount}" data-type="${transaction.transaction_type}">
                                </td>
                                <td>${formatDate(transaction.transaction_date)}</td>
                                <td>${transaction.to_account_name || getAccountName(transaction.to_account_id) || 'Unknown'}</td>
                                <td>${transaction.reference_number || '-'}</td>
                                <td style="color: ${transaction.transaction_type === 'credit' ? 'var(--banking-green)' : 'var(--banking-red)'};">
                                    ${transaction.transaction_type === 'credit' ? '+' : '-'}${formatCurrency(Math.abs(transaction.amount))}
                                </td>
                                <td><span class="badge badge-warning">Pending</span></td>
                                <td style="display: flex; gap: 0.5rem;">
                                    <button class="btn btn-secondary" style="padding: 0.25rem 0.5rem; font-size: 0.75rem;" onclick="editTransactionFromReconcile('${transaction.id}')">Edit</button>
                                    <button class="btn btn-danger" style="padding: 0.25rem 0.5rem; font-size: 0.75rem;" onclick="deleteTransactionFromReconcile('${transaction.id}')">Delete</button>
                                </td>
                            </tr>
                        `).join('');
                    }
                }
                
                // Set up event listener for statement balance input
                const statementBalanceInput = modal.querySelector('[name="statementBalance"]');
                if (statementBalanceInput) {
                    // Remove any existing listeners
                    statementBalanceInput.removeEventListener('input', updateReconcileBalance);
                    // Add new listener
                    statementBalanceInput.addEventListener('input', updateReconcileBalance);
                }
                
                // Update balance summary
                updateReconcileBalanceSummary(account, []);
            } catch (error) {
                console.error('Error populating reconcile modal:', error);
            }
        }
        
        function updateReconcileBalanceSummary(account, clearedTransactions = []) {
            // Handle both wrapped and unwrapped account objects
            const accountData = account.data || account;
            const currentBalance = (accountData.account_balance || 0) + (accountData.opening_balance || 0);
            
            // Calculate debits and credits from selected transactions
            let totalDebits = 0;
            let totalCredits = 0;
            
            clearedTransactions.forEach(transaction => {
                const amount = Math.abs(parseFloat(transaction.amount) || 0);
                if (transaction.transaction_type === 'credit') {
                    totalCredits += amount;
                } else {
                    totalDebits += amount;
                }
            });
            
            // Get new statement balance from form
            const statementBalanceInput = document.querySelector('[name="statementBalance"]');
            const newStatementBalance = parseFloat(statementBalanceInput?.value || 0);
            
            // Get last statement balance from the reconciliation history
            const lastStatementBalanceEl = document.querySelector('#liabilities-section');
            const lastStatementBalanceText = lastStatementBalanceEl?.textContent || '$0.00';
            const lastStatementBalance = parseFloat(lastStatementBalanceText.replace(/[$,]/g, ''));
            
            // Correct reconciliation formula: Last Statement Balance + Credits - Debits should equal New Statement Balance
            // Difference = (Last Statement Balance + Credits - Debits) - New Statement Balance
            const calculatedBalance = lastStatementBalance + totalCredits - totalDebits;
            const difference = calculatedBalance - newStatementBalance;
            
            // Update summary cards
            const debitsEl = document.getElementById('reconcile-debits');
            const creditsEl = document.getElementById('reconcile-credits');
            const differenceEl = document.getElementById('reconcile-difference');
            
            if (debitsEl) debitsEl.textContent = formatCurrency(totalDebits);
            if (creditsEl) creditsEl.textContent = formatCurrency(totalCredits);
            if (differenceEl) {
                differenceEl.textContent = formatCurrency(Math.abs(difference));
                // Color coding for difference
                if (Math.abs(difference) < 0.01) { // Essentially zero (accounting for floating point precision)
                    differenceEl.style.color = 'var(--banking-green)';
                } else {
                    differenceEl.style.color = 'var(--banking-red)';
                }
            }
            
            // Enable/disable Complete Reconciliation button based on difference
            const completeButton = document.querySelector('#reconcile-modal .btn-success');
            if (completeButton) {
                const isBalanced = Math.abs(difference) < 0.01;
                completeButton.disabled = !isBalanced;
                completeButton.style.opacity = isBalanced ? '1' : '0.6';
                completeButton.style.cursor = isBalanced ? 'pointer' : 'not-allowed';
                completeButton.style.backgroundColor = isBalanced ? '' : '#6b7280';
                
                if (isBalanced) {
                    completeButton.textContent = 'Complete Reconciliation';
                } else {
                    completeButton.textContent = `Complete Reconciliation (Off by ${formatCurrency(Math.abs(difference))})`;
                }
            }
        }
        
        function updateReconcileBalance() {
            // Get all checked transactions
            const checkboxes = document.querySelectorAll('#reconcile-modal input[type="checkbox"]:checked');
            const clearedTransactions = Array.from(checkboxes).map(checkbox => ({
                id: checkbox.dataset.transactionId,
                amount: checkbox.dataset.amount,
                transaction_type: checkbox.dataset.type
            }));
            
            // Get current account info from the modal's stored data
            const modal = document.getElementById('reconcile-modal');
            const accountId = modal?.getAttribute('data-account-id');
            
            // Find the account data (this should be stored in a global variable when modal opens)
            let currentBalance = 0;
            if (window.currentReconcileAccount) {
                const accountData = window.currentReconcileAccount.data || window.currentReconcileAccount;
                currentBalance = (accountData.account_balance || 0) + (accountData.opening_balance || 0);
            } else {
                // Fallback: try to get from the displayed current balance
                const currentBalanceEl = document.querySelector('#reconcile-modal .info-value[style*="font-size: 1.125rem"]');
                if (currentBalanceEl) {
                    currentBalance = parseFloat(currentBalanceEl.textContent.replace(/[$,]/g, ''));
                }
            }
            
            updateReconcileBalanceSummary({ account_balance: currentBalance, opening_balance: 0 }, clearedTransactions);
        }
        
        function markAllCleared() {
            const checkboxes = document.querySelectorAll('#reconcile-modal input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = true;
            });
            updateReconcileBalance();
        }
        
        function unmarkAll() {
            const checkboxes = document.querySelectorAll('#reconcile-modal input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            updateReconcileBalance();
        }
        
        // Toggle all transactions in reconcile modal
        function toggleAllTransactions(toggleCheckbox) {
            const checkboxes = document.querySelectorAll('#reconcile-modal input[type="checkbox"]:not(#toggle-mark-unmark)');
            checkboxes.forEach(checkbox => {
                checkbox.checked = toggleCheckbox.checked;
            });
            updateReconcileBalance();
        }
        
        // Close Add Transaction modal with proper return navigation
        async function closeAddTransactionModal() {
            const modal = document.getElementById('add-transaction-modal');
            if (!modal) return;
            
            const returnAccountId = modal.getAttribute('data-return-account-id');
            const returnSource = modal.getAttribute('data-return-source');
            
            // Clear form and attributes
            const form = modal.querySelector('form');
            if (form) {
                form.reset();
            }
            modal.removeAttribute('data-account-id');
            modal.removeAttribute('data-return-account-id');
            modal.removeAttribute('data-return-source');
            
            closeModal('add-transaction-modal');
            
            // Handle return to source modal
            if (returnSource === 'transaction-list-modal' && returnAccountId) {
                try {
                    await openTransactionListModal(returnAccountId);
                } catch (error) {
                    console.error('Error reopening transaction list modal:', error);
                }
            } else if (returnSource === 'reconcile-modal' && returnAccountId) {
                try {
                    await openReconcileModal(returnAccountId);
                } catch (error) {
                    console.error('Error reopening reconcile modal:', error);
                }
            }
        }
        
        // Add transaction from transaction list modal
        async function addTransactionFromTransactionList() {
            try {
                // Store the current account ID from transaction list modal for returning
                const transactionListModal = document.getElementById('list-transactions-modal');
                const accountId = transactionListModal ? transactionListModal.getAttribute('data-account-id') : null;
                
                // Close transaction list modal first
                closeModal('list-transactions-modal');
                
                // Get account details for pre-population
                let account = null;
                if (accountId) {
                    account = await loadAccountById(accountId);
                }
                
                // Use the standard openAddTransactionModal function which properly handles pre-population
                await openAddTransactionModal(accountId);
                
                // Store return navigation info AFTER the modal is opened
                const addModal = document.getElementById('add-transaction-modal');
                if (addModal) {
                    if (accountId) {
                        addModal.setAttribute('data-return-account-id', accountId);
                    }
                    addModal.setAttribute('data-return-source', 'transaction-list-modal');
                }
                
            } catch (error) {
                console.error('Error opening add transaction modal from transaction list:', error);
                showNotification('Failed to open add transaction form', 'error');
            }
        }
        
        // Add transaction from reconcile modal
        async function addTransactionFromReconcile() {
            try {
                // Store the current account ID from reconcile modal for returning
                const reconcileModal = document.getElementById('reconcile-modal');
                const accountId = reconcileModal ? reconcileModal.getAttribute('data-account-id') : null;
                
                // Close reconcile modal first
                closeModal('reconcile-modal');
                
                // Get account details for pre-population
                let account = null;
                if (accountId) {
                    account = await loadAccountById(accountId);
                }
                
                // Use the standard openAddTransactionModal function which properly handles pre-population
                await openAddTransactionModal(accountId);
                
                // Store return navigation info AFTER the modal is opened
                const addModal = document.getElementById('add-transaction-modal');
                if (addModal) {
                    if (accountId) {
                        addModal.setAttribute('data-return-account-id', accountId);
                    }
                    addModal.setAttribute('data-return-source', 'reconcile-modal');
                }
                
            } catch (error) {
                console.error('Error opening add transaction modal from reconcile:', error);
                showNotification('Failed to open add transaction form', 'error');
            }
        }
        
        // Edit transaction from reconcile modal
        async function editTransactionFromReconcile(transactionId) {
            try {
                const transaction = await loadTransactionById(transactionId);
                
                // Store the account ID from reconcile modal for returning
                const reconcileModal = document.getElementById('reconcile-modal');
                const accountId = reconcileModal ? reconcileModal.getAttribute('data-account-id') : null;
                
                // Close reconcile modal first
                closeModal('reconcile-modal');
                
                // Store account ID and source in Edit modal for return navigation
                const editModal = document.getElementById('edit-transaction-modal');
                if (editModal) {
                    if (accountId) {
                        editModal.setAttribute('data-return-account-id', accountId);
                    }
                    editModal.setAttribute('data-return-source', 'reconcile-modal');
                }
                
                await populateEditTransactionModal(transaction);
                openModal('edit-transaction-modal');
            } catch (error) {
                console.error('Error opening edit transaction modal from reconcile:', error);
                showNotification('Failed to load transaction for editing', 'error');
            }
        }
        
        // Delete transaction from reconcile modal
        async function deleteTransactionFromReconcile(transactionId) {
            try {
                const transaction = await loadTransactionById(transactionId);
                
                // Check if we're in the Reconcile Modal to track source
                const reconcileModal = document.getElementById('reconcile-modal');
                const deleteModal = document.getElementById('delete-confirmation');
                
                if (reconcileModal && reconcileModal.classList.contains('active')) {
                    // Store the account ID for refreshing the Reconcile Modal
                    const accountId = reconcileModal.getAttribute('data-account-id');
                    if (accountId && deleteModal) {
                        deleteModal.setAttribute('data-return-source', 'reconcile-modal');
                        deleteModal.setAttribute('data-return-account-id', accountId);
                    }
                } else if (deleteModal) {
                    // Clear any previous source tracking
                    deleteModal.removeAttribute('data-return-source');
                    deleteModal.removeAttribute('data-return-account-id');
                }
                
                // Set up delete confirmation modal for transaction
                deleteModal.setAttribute('data-delete-type', 'transaction');
                deleteModal.setAttribute('data-delete-id', transactionId);
                
                // Populate the unified delete confirmation modal
                populateDeleteTransactionModal(transaction);
                
                // Close reconcile modal and open delete confirmation
                closeModal('reconcile-modal');
                openModal('delete-confirmation');
            } catch (error) {
                console.error('Error setting up delete confirmation for reconcile transaction:', error);
                showNotification('Failed to load transaction for deletion', 'error');
            }
        }

        async function populateAccountSelects(container) {
            try {
                const accounts = await getAccountsFromCache();
                const selects = container.querySelectorAll('select');
                
                selects.forEach(select => {
                    if (select.name === 'fromAccount' || select.name === 'toAccount' || select.classList.contains('account-select')) {
                        // Sort accounts by account code for better organization
                        const accountsArray = Array.isArray(accounts) ? accounts : [];
                        const sortedAccounts = accountsArray.sort((a, b) => (a.account_code || '').localeCompare(b.account_code || ''));
                        
                        select.innerHTML = '<option value="">Select Account</option>' +
                            sortedAccounts.map(account => {
                                // Parent accounts have no parent_code (they are top-level)
                                const isParent = !account.parent_code;
                                
                                if (isParent) {
                                    // Parent accounts: bold, blue color, and disabled
                                    return `<option value="" disabled style="font-weight: bold; color: var(--banking-blue); background-color: #f8fafc;">${account.account_name}</option>`;
                                } else {
                                    // Child accounts: indented, normal styling, selectable
                                    return `<option value="${account.id}" style="padding-left: 20px;">&nbsp;&nbsp;&nbsp;&nbsp;${account.account_name}</option>`;
                                }
                            }).join('');
                    }
                });
            } catch (error) {
                console.error('Failed to populate account selects:', error);
            }
        }

        // Transaction page specific modal functions
        async function openTransactionPageAddModal() {
            try {
                await populateAddTransactionModal(null, false);
                openModal('add-transaction-modal');
            } catch (error) {
                console.error('Error opening add transaction modal:', error);
                showNotification('Failed to open transaction form', 'error');
            }
        }

        async function loadTransactionById(transactionId) {
            try {
                const response = await apiCall(`/transactions/${transactionId}`);
                return response.data;
            } catch (error) {
                console.error('Failed to load transaction:', error);
                throw error;
            }
        }

        async function getAccountNameById(accountId) {
            try {
                const accounts = await getAccountsFromCache();
                const account = accounts.find(acc => acc.id === accountId);
                return account ? account.account_name : 'Unknown Account';
            } catch (error) {
                console.error('Failed to get account name:', error);
                return 'Unknown Account';
            }
        }

        async function closeEditTransactionModal() {
            const editModal = document.getElementById('edit-transaction-modal');
            const returnAccountId = editModal ? editModal.getAttribute('data-return-account-id') : null;
            const returnSource = editModal ? editModal.getAttribute('data-return-source') : null;
            
            // Close the Edit Transaction modal
            closeModal('edit-transaction-modal');
            
            // Determine where to return based on the source
            if (returnSource === 'transactions-page--------') {
                // Return to Transactions page - just refresh the page data
                try {
                    console.log('Passei por aqui... ', '2987');
                    await updateTransactions();
                    await updateDashboard();
                } catch (error) {
                    console.error('Error refreshing transactions page:', error);
                }
            } else if (returnSource === 'reconcile-modal' && returnAccountId) {
                // Return to Reconcile modal
                try {
                    await openReconcileModal(returnAccountId);
                } catch (error) {
                    console.error('Error reopening reconcile modal:', error);
                }
            } else if (returnAccountId) {
                // Return to Transaction List modal
                try {
                    await openTransactionListModal(returnAccountId);
                } catch (error) {
                    console.error('Error reopening transaction list modal:', error);
                }
            }
        }

        async function populateEditTransactionModal(transaction) {
            if (!transaction) return;
            
            const modal = document.getElementById('edit-transaction-modal');
            if (modal) {
                // Update the info card with from account name only
                const infoValue = modal.querySelector('.info-value');
                
                // Get from account name
                const fromAccountName = await getAccountNameById(transaction.from_account_id);
                
                if (infoValue) {
                    infoValue.textContent = fromAccountName || 'Unknown Account';
                }
                
                // Set the radio buttons for transaction type
                const debitRadio = modal.querySelector('#debit-edit');
                const creditRadio = modal.querySelector('#credit-edit');
                if (transaction.transaction_type === 'debit') {
                    if (debitRadio) debitRadio.checked = true;
                    if (creditRadio) creditRadio.checked = false;
                } else {
                    if (creditRadio) creditRadio.checked = true;
                    if (debitRadio) debitRadio.checked = false;
                }
                
                // First populate account selects with real data
                await populateAccountSelects(modal);
                
                // Then populate form fields with transaction data
                const form = modal.querySelector('form');
                if (form) {
                    const fields = {
                        'date': formatDateForInput(transaction.transaction_date),
                        'description': transaction.description || '',
                        'amount': Math.abs(transaction.amount).toString(),
                        'toAccount': transaction.to_account_id,
                        'referenceNumber': transaction.reference_number || ''
                    };
                    
                    // Set the hidden fromAccount field
                    const fromAccountField = modal.querySelector('#edit-from-account-id');
                    if (fromAccountField) {
                        fromAccountField.value = transaction.from_account_id;
                    }
                    
                    Object.entries(fields).forEach(([name, value]) => {
                        const field = form.querySelector(`[name="${name}"]`);
                        if (field) {
                            field.value = value;
                        }
                    });
                    
                    // Store transaction ID for form submission
                    modal.setAttribute('data-transaction-id', transaction.id);
                }
            }
        }

        function populateDeleteTransactionModal(transaction) {
            if (!transaction) return;
            
            const modal = document.getElementById('delete-transaction-modal');
            if (modal) {
                // Update transaction details in delete confirmation
                const detailsContainer = modal.querySelector('.transaction-details');
                if (detailsContainer) {
                    detailsContainer.innerHTML = `
                        <div class="alert alert-warning" style="margin-bottom: 1rem; padding: 1rem; background-color: #fef3c7; border: 1px solid #f59e0b; border-radius: 0.5rem;">
                            <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                                <svg style="width: 20px; height: 20px; color: #f59e0b;" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path>
                                </svg>
                                <span style="font-weight: 600; color: #92400e;">Warning: This action cannot be undone</span>
                            </div>
                            <p style="color: #92400e; margin: 0; font-size: 0.875rem;">Deleting this transaction will permanently remove it from your records.</p>
                        </div>
                        <div style="background-color: #f9fafb; padding: 1rem; border-radius: 0.5rem; border: 1px solid #e5e7eb;">
                            <h4 style="margin: 0 0 0.75rem 0; color: #374151; font-size: 1rem; font-weight: 600;">Transaction Details:</h4>
                            <div style="display: grid; gap: 0.5rem;">
                                <div style="display: flex; justify-content: space-between;">
                                    <span style="color: #6b7280; font-weight: 500;">Date:</span>
                                    <span style="color: #374151; font-weight: 600;">${formatDate(transaction.transaction_date)}</span>
                                </div>
                                <div style="display: flex; justify-content: space-between;">
                                    <span style="color: #6b7280; font-weight: 500;">Description:</span>
                                    <span style="color: #374151; font-weight: 600;">${transaction.description || ''}</span>
                                </div>
                                <div style="display: flex; justify-content: space-between;">
                                    <span style="color: #6b7280; font-weight: 500;">Amount:</span>
                                    <span style="color: #dc2626; font-weight: 700; font-size: 1.1rem;">${formatCurrency(Math.abs(transaction.amount))}</span>
                                </div>
                                <div style="display: flex; justify-content: space-between;">
                                    <span style="color: #6b7280; font-weight: 500;">From Account:</span>
                                    <span style="color: #374151; font-weight: 600;">${transaction.from_account_name || getAccountName(transaction.from_account_id) || 'Unknown'}</span>
                                </div>
                                <div style="display: flex; justify-content: space-between;">
                                    <span style="color: #6b7280; font-weight: 500;">To Account:</span>
                                    <span style="color: #374151; font-weight: 600;">${transaction.to_account_name || getAccountName(transaction.to_account_id) || 'Unknown'}</span>
                                </div>
                            </div>
                        </div>
                    `;
                }
                
                // Store transaction ID for deletion
                modal.setAttribute('data-transaction-id', transaction.id);
            }
        }

        function formatDateForInput(dateString) {
            if (!dateString) return '';
            
            // Handle date string directly to avoid timezone conversion issues
            // Database dates are stored as YYYY-MM-DD strings
            if (typeof dateString === 'string' && dateString.match(/^\d{4}-\d{2}-\d{2}/)) {
                // Extract just the date part (YYYY-MM-DD) in case there's time data
                return dateString.substring(0, 10);
            }
            
            // Fallback for other date formats - use UTC methods to avoid timezone shifts
            const date = new Date(dateString);
            if (isNaN(date.getTime())) return '';
            
            const year = date.getUTCFullYear();
            const month = String(date.getUTCMonth() + 1).padStart(2, '0');
            const day = String(date.getUTCDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }


        // Transaction action functions
        async function editTransaction(transactionId) {
            try {
                const transaction = await loadTransactionById(transactionId);
                
                // Store the account ID from the Transaction List modal for returning
                const transactionListModal = document.getElementById('list-transactions-modal');
                const accountId = transactionListModal ? transactionListModal.getAttribute('data-account-id') : null;
                
                // Close Transaction List modal first
                closeModal('list-transactions-modal');
                
                // Store account ID and source in Edit modal for return navigation
                const editModal = document.getElementById('edit-transaction-modal');
                if (editModal && accountId) {
                    editModal.setAttribute('data-return-account-id', accountId);
                    editModal.setAttribute('data-return-source', 'transaction-list-modal');
                }
                
                await populateEditTransactionModal(transaction);
                openModal('edit-transaction-modal');
            } catch (error) {
                console.error('Error opening edit transaction modal:', error);
                showNotification('Failed to load transaction for editing', 'error');
            }
        }

        async function deleteTransaction(transactionId) {
            try {
                const transaction = await loadTransactionById(transactionId);
                
                // Check if we're in the Transaction List Modal to track source
                const transactionListModal = document.getElementById('list-transactions-modal');
                const deleteModal = document.getElementById('delete-confirmation');
                
                if (transactionListModal && transactionListModal.classList.contains('active')) {
                    // Store the account ID for refreshing the Transaction List Modal
                    const accountId = transactionListModal.getAttribute('data-account-id');
                    if (accountId && deleteModal) {
                        deleteModal.setAttribute('data-return-source', 'transaction-list-modal');
                        deleteModal.setAttribute('data-return-account-id', accountId);
                    }
                }
                
                // Set up delete confirmation modal for transaction
                deleteModal.setAttribute('data-delete-type', 'transaction');
                deleteModal.setAttribute('data-delete-id', transactionId);
                
                // Populate transaction details
                const detailsDiv = document.getElementById('delete-item-details');
                detailsDiv.querySelector('div:first-child').textContent = 'Transaction to delete:';
                detailsDiv.querySelector('div:last-child').innerHTML = `
                    <strong>Date:</strong> ${formatDate(transaction.transaction_date)}<br>
                    <strong>Amount:</strong> ${formatCurrency(Math.abs(transaction.amount))}<br>
                    <strong>Description:</strong> ${transaction.description || 'No description'}
                `;
                
                openModal('delete-confirmation');
            } catch (error) {
                console.error('Error opening delete transaction modal:', error);
                showNotification('Failed to load transaction for deletion', 'error');
            }
        }

        async function deleteTransactionFromEdit() {
            const modal = document.getElementById('edit-transaction-modal');
            const transactionId = modal.getAttribute('data-transaction-id');
            if (transactionId) {
                try {
                    const transaction = await loadTransactionById(transactionId);
                    populateDeleteTransactionModal(transaction);
                    closeModal('edit-transaction-modal');
                    openModal('delete-transaction-modal');
                } catch (error) {
                    console.error('Error opening delete transaction modal from edit:', error);
                    showNotification('Failed to load transaction for deletion', 'error');
                }
            } else {
                showNotification('No transaction selected for deletion', 'error');
            }
        }

        /******************************************************************REPORTS PAGE *******************************************************************/

        async function updateReports() {
            if (!currentCheckbookId) return;

            try {
                showLoading('reports-page');
                
                // Reset filter selectors to their default values when page loads
                const periodSelect = document.getElementById('td-period-filter');
                const accountSelect = document.getElementById('td-account-filter');
                if (periodSelect) periodSelect.value = 'this-year';
                if (accountSelect) accountSelect.value = '';
                
                const [reports, accounts, transactions, chartOfAccountsData, balanceSheetData, profitLossData] = await Promise.all([
                    loadReports(currentCheckbookId),
                    getAccountsFromCache(),
                    loadTransactions(currentCheckbookId),
                    apiCall(`/reports/chart-of-accounts/${currentCheckbookId}`),
                    apiCall(`/reports/balance-sheet/${currentCheckbookId}`),
                    apiCall(`/reports/profit-loss/${currentCheckbookId}`)
                ]);
                
                // Cache all accounts for P&L parent name lookup
                window.accountsCache = accounts;
                
                updateChartOfAccountsReport(chartOfAccountsData.data);
                updateBalanceSheetReport(balanceSheetData.data);
                updateProfitLossReport(profitLossData.data);

                
                hideLoading('reports-page');
            } catch (error) {
                console.error('Failed to update reports:', error);
                hideLoading('reports-page');
            }
        }

        function updateChartOfAccountsReport(accounts) {
            const tbody = document.querySelector('#chart-of-accounts .table tbody');
            if (!tbody) return;

            if (accounts.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="5" style="text-align: center; padding: 2rem; color: #6b7280;">
                            No accounts found
                        </td>
                    </tr>
                `;
                return;
            }

            // Group accounts by type for better chart of accounts display
            const accountGroups = ['asset', 'liability', 'equity', 'income', 'expense'];
            const typeLabels = {
                'asset': 'ASSETS',
                'liability': 'LIABILITIES', 
                'equity': 'EQUITY',
                'income': 'INCOME',
                'expense': 'EXPENSES'
            };

            let html = '';
            let totalAssets = 0;
            let totalLiabilities = 0;
            let totalEquity = 0;
            let totalIncome = 0;
            let totalExpenses = 0;

            accountGroups.forEach(type => {
                const typeAccounts = accounts.filter(acc => acc.account_type === type);
                if (typeAccounts.length === 0) return;

                const typeTotal = typeAccounts.reduce((sum, acc) => sum + (acc.balance || 0), 0);
                
                // Track totals for summary
                if (type === 'asset') totalAssets = typeTotal;
                if (type === 'liability') totalLiabilities = typeTotal;
                if (type === 'equity') totalEquity = typeTotal;
                if (type === 'income') totalIncome = typeTotal;
                if (type === 'expense') totalExpenses = typeTotal;

                // Add type header
                html += `
                    <tr style="font-weight: 700; background: #f1f5f9; border-top: 2px solid #e2e8f0;">
                        <td></td>
                        <td>${typeLabels[type]}</td>
                        <td>${type.charAt(0).toUpperCase() + type.slice(1)}</td>
                        <td style="font-weight: 700; text-align: right;">${formatCurrency(typeTotal)}</td>
                    </tr>
                `;

                // Group accounts by parent for this account type
                const parentGroups = new Map();
                const childAccounts = [];
                const standaloneAccounts = [];

                typeAccounts.forEach(account => {
                    if (!account.parent_code) {
                        // This could be a parent account or standalone account
                        const hasChildren = typeAccounts.some(child => child.parent_code === account.account_code);
                        if (hasChildren) {
                            if (!parentGroups.has(account.account_code)) {
                                parentGroups.set(account.account_code, {
                                    parent: account,
                                    children: []
                                });
                            }
                        } else {
                            standaloneAccounts.push(account);
                        }
                    } else {
                        // This is a child account
                        childAccounts.push(account);
                    }
                });

                // Group children with their parents
                childAccounts.forEach(child => {
                    if (parentGroups.has(child.parent_code)) {
                        parentGroups.get(child.parent_code).children.push(child);
                    } else {
                        // Parent not found, treat as standalone
                        standaloneAccounts.push(child);
                    }
                });

                // Display parent groups with their children and parent totals
                parentGroups.forEach(group => {
                    const parentTotal = (group.parent.balance || 0) + 
                                       group.children.reduce((sum, child) => sum + (child.balance || 0), 0);

                    // Add parent account with total
                    html += `
                        <tr style="font-weight: 600; background: #f8fafc;">
                            <td>${group.parent.account_code || ''}</td>
                            <td>&nbsp;&nbsp;${group.parent.account_name}</td>
                            <td>${group.parent.account_type}</td>
                            <td style="text-align: right; font-weight: 600;">${formatCurrency(parentTotal)}</td>
                        </tr>
                    `;

                    // Add child accounts indented
                    group.children.forEach(child => {
                        html += `
                            <tr>
                                <td>${child.account_code || ''}</td>
                                <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${child.account_name}</td>
                                <td>${child.account_type}</td>
                                <td style="text-align: right;">${formatCurrency(child.balance || 0)}</td>
                            </tr>
                        `;
                    });
                });

                // Add standalone accounts (no parent-child relationship)
                standaloneAccounts.forEach(account => {
                    html += `
                        <tr>
                            <td>${account.account_code || ''}</td>
                            <td>&nbsp;&nbsp;${account.account_name}</td>
                            <td>${account.account_type}</td>
                            <td style="text-align: right;">${formatCurrency(account.balance || 0)}</td>
                        </tr>
                    `;
                });
            });

            // Add summary totals
            html += `
                <tr style="height: 1rem;"><td colspan="4"></td></tr>
                <tr style="font-weight: 700; background: #dbeafe; border-top: 2px solid #3b82f6;">
                    <td></td>
                    <td>TOTAL NET WORTH</td>
                    <td></td>
                    <td style="font-size: 1.125rem; color: var(--banking-blue); text-align: right;">${formatCurrency(totalAssets - totalLiabilities + totalEquity)}</td>
                </tr>
            `;

            tbody.innerHTML = html;
        }

        function updateProfitLossReport(accounts) {
            const tbody = document.querySelector('#profit-loss .table tbody');
            if (!tbody) return;

            // Ensure accounts is an array
            const accountsArray = Array.isArray(accounts) ? accounts : [];
            
            // Handle both detailed account data and summarized data
            let totalIncome = 0, totalExpenses = 0;
            let incomeParents = new Map(), expenseParents = new Map();
            
            if (accountsArray.length > 0 && accountsArray[0].account_name) {
                // Detailed account data - group by parent accounts for high-level summary
                const income = accountsArray.filter(acc => acc.account_type === 'income');
                const expenses = accountsArray.filter(acc => acc.account_type === 'expense');
                
                // Get all Chart of Accounts data to find parent account names
                const allAccounts = window.accountsCache || [];
                
                // Group income accounts by parent code 
                income.forEach(acc => {
                    const parentCode = acc.parent_code || 'no-parent';
                    const balance = acc.balance || 0;
                    
                    if (!incomeParents.has(parentCode)) {
                        incomeParents.set(parentCode, {
                            code: parentCode,
                            name: getParentAccountName(parentCode, 'income', allAccounts),
                            balance: 0
                        });
                    }
                    incomeParents.get(parentCode).balance += Math.abs(balance);
                    totalIncome += Math.abs(balance);
                });
                
                // Group expense accounts by parent code
                expenses.forEach(acc => {
                    const parentCode = acc.parent_code || 'no-parent';
                    const balance = acc.balance || 0;
                    
                    if (!expenseParents.has(parentCode)) {
                        expenseParents.set(parentCode, {
                            code: parentCode,
                            name: getParentAccountName(parentCode, 'expense', allAccounts),
                            balance: 0
                        });
                    }
                    // For expenses: positive balance = expense, negative balance = refund (reduces total)
                    expenseParents.get(parentCode).balance += balance;
                    totalExpenses += balance;
                });
                
            } else {
                // Summarized data by type (fallback)
                const incomeData = accounts.find(acc => acc.account_type === 'income');
                const expenseData = accounts.find(acc => acc.account_type === 'expense');
                
                totalIncome = incomeData ? Math.abs(incomeData.total_balance || 0) : 0;
                totalExpenses = expenseData ? Math.abs(expenseData.total_balance || 0) : 0;
                
                // Create simple entries for summary view
                if (totalIncome > 0) {
                    incomeParents.set('00', { code: '00', name: 'Total Income', balance: totalIncome });
                }
                if (totalExpenses > 0) {
                    expenseParents.set('00', { code: '00', name: 'Total Expenses', balance: totalExpenses });
                }
            }
            
            const netIncome = totalIncome - totalExpenses;

            // Helper function to get parent account name from actual database data
            function getParentAccountName(parentCode, accountType, allAccounts) {
                if (!parentCode || parentCode === 'no-parent') {
                    return 'Uncategorized';
                }
                
                // Find the actual parent account with this code
                const parentAccount = allAccounts.find(acc => 
                    acc.account_code === parentCode && 
                    !acc.parent_code // Parent accounts have no parent themselves
                );
                
                if (parentAccount) {
                    return parentAccount.account_name;
                }
                
                // If parent not found, return the parent code
                return `Account ${parentCode}`;
            }

            // Sort parent accounts by code
            const sortedIncomeParents = Array.from(incomeParents.values()).sort((a, b) => a.code.localeCompare(b.code));
            const sortedExpenseParents = Array.from(expenseParents.values()).sort((a, b) => a.code.localeCompare(b.code));

            tbody.innerHTML = [
                // Income section header
                `<tr style="font-weight: 600; background: #dcfce7;">
                    <td>INCOME</td>
                    <td style="text-align: right; color: var(--banking-green);">${formatCurrency(totalIncome)}</td>
                    <td style="text-align: right;">100.0%</td>
                </tr>`,
                // Income parent accounts
                ...sortedIncomeParents.map(parent => `
                    <tr>
                        <td>&nbsp;&nbsp;${parent.name}</td>
                        <td style="text-align: right;">${formatCurrency(parent.balance)}</td>
                        <td style="text-align: right;">${totalIncome > 0 ? ((parent.balance / totalIncome) * 100).toFixed(1) : '0.0'}%</td>
                    </tr>
                `),
                `<tr style="height: 1rem;"><td colspan="3"></td></tr>`,
                // Expenses section header
                `<tr style="font-weight: 600; background: #fee2e2;">
                    <td>EXPENSES</td>
                    <td style="text-align: right; color: var(--banking-red);">${formatCurrency(totalExpenses)}</td>
                    <td style="text-align: right;">${totalIncome > 0 ? ((totalExpenses / totalIncome) * 100).toFixed(1) : '0.0'}%</td>
                </tr>`,
                // Expense parent accounts
                ...sortedExpenseParents.map(parent => `
                    <tr>
                        <td>&nbsp;&nbsp;${parent.name}</td>
                        <td style="text-align: right;">${formatCurrency(parent.balance)}</td>
                        <td style="text-align: right;">${totalIncome > 0 ? ((parent.balance / totalIncome) * 100).toFixed(1) : '0.0'}%</td>
                    </tr>
                `),
                `<tr style="height: 1rem;"><td colspan="3"></td></tr>`,
                // Net income
                `<tr style="font-weight: 600; background: #dbeafe; border-top: 2px solid var(--banking-blue);">
                    <td>NET INCOME</td>
                    <td style="text-align: right; color: var(--banking-blue); font-size: 1.125rem;">${formatCurrency(netIncome)}</td>
                    <td style="text-align: right; color: var(--banking-blue);">${totalIncome > 0 ? ((netIncome / totalIncome) * 100).toFixed(1) : '0.0'}%</td>
                </tr>`
            ].join('');
        }

        /*****************************************************Filters: Period & Type, Parent****************************************************************/

        // Update P&L report based on selected period
        async function updateProfitLossPeriod() {
            if (!currentCheckbookId) return;
            
            try {
                const periodSelect = document.getElementById('pl-period-filter');
                const period = periodSelect.value;
                
                // Calculate date ranges
                const now = new Date();
                let startDate, endDate;
                
                if (period === 'this-month') {
                    startDate = new Date(now.getFullYear(), now.getMonth(), 1);
                    endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0);
                } else if (period === 'last-month') {
                    startDate = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                    endDate = new Date(now.getFullYear(), now.getMonth(), 0);
                } else if (period === 'this-year') {
                    startDate = new Date(now.getFullYear(), 0, 1);
                    endDate = new Date(now.getFullYear(), 11, 31);
                } else if (period === 'last-year') {
                    startDate = new Date(now.getFullYear() - 1, 0, 1);
                    endDate = new Date(now.getFullYear() - 1, 11, 31);
                }
                
                const startDateStr = startDate.toISOString().split('T')[0];
                const endDateStr = endDate.toISOString().split('T')[0];
                
                // Load filtered P&L report
                const response = await apiCall(`/reports/profit-loss/${currentCheckbookId}?start_date=${startDateStr}&end_date=${endDateStr}`);
                updateProfitLossReport(response.data || []);
                
            } catch (error) {
                console.error('Failed to update P&L period:', error);
                showNotification('Failed to update Profit & Loss report', 'error');
            }
        }

        // Update Transaction Detail report based on selected period and account
        async function updateTransactionDetailPeriod() {

            if (!currentCheckbookId) {
                console.warn('updateTransactionDetailPeriod: No checkbook ID');
                return;
            }
            
            try {
                const periodSelect = document.getElementById('td-period-filter');
                const accountSelect = document.getElementById('td-account-filter');
                
                if (!periodSelect || !accountSelect) {
                    console.error('updateTransactionDetailPeriod: DOM elements not found', {
                        periodSelect: !!periodSelect,
                        accountSelect: !!accountSelect
                    });
                    return;
                }
                
                const period = periodSelect.value || 'this-year'; // Default fallback
                const filterValue = accountSelect.value || '';
                
                // console.log('updateTransactionDetailPeriod called with:', { period, filterValue, currentCheckbookId });
                
                // Calculate date ranges - force to 2025 since that's where our data is
                const now = new Date();
                let startDate, endDate;
                
                if (period === 'this-month') {
                    startDate = new Date(now.getFullYear(), now.getMonth(), 1);
                    endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0);
                } else if (period === 'last-month') {
                    startDate = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                    endDate = new Date(now.getFullYear(), now.getMonth(), 0);
                } else if (period === 'this-year') {
                    startDate = new Date(now.getFullYear(), 0, 1);
                    endDate = new Date(now.getFullYear(), 11, 31);
                } else if (period === 'last-year') {
                    startDate = new Date(now.getFullYear() - 1, 0, 1);
                    endDate = new Date(now.getFullYear() - 1, 11, 31);
                }
                
                const startDateStr = startDate.toISOString().split('T')[0];
                const endDateStr = endDate.toISOString().split('T')[0];
                
                // console.log('Date range calculated:', { startDateStr, endDateStr });
                
                // Build query parameters
                let queryParams = `start_date=${startDateStr}&end_date=${endDateStr}`;
                
                // Handle different filter types
                if (filterValue) {
                    if (filterValue.startsWith('type:')) {
                        // Filter by account type
                        const accountType = filterValue.replace('type:', '');
                        queryParams += `&account_type=${accountType}`;
                    } else if (filterValue.startsWith('parent:')) {
                        // Filter by parent account code - we need to get all accounts with this parent code
                        const parentCode = filterValue.replace('parent:', '');
                        queryParams += `&parent_code=${parentCode}`;
                    } else {
                        // Individual account ID (backward compatibility)
                        queryParams += `&account_id=${filterValue}`;
                    }
                }
                
                const apiUrl = `/reports/transaction-detail/${currentCheckbookId}?${queryParams}`;
                // console.log('Making API call to:', apiUrl);
                
                // Load filtered transaction detail report
                const response = await apiCall(apiUrl);
                console.log('API response received:', { 
                    status: response?.status, 
                    dataLength: response?.data?.length,
                    hasData: !!(response?.data && response.data.length > 0),
                    data: response?.data
                });
                
                await updateTransactionDetailReport(response.data || []);
                
            } catch (error) {
                console.error('Failed to update transaction detail period:', error);
                showNotification('Failed to update Transaction Detail report', 'error');
            }
        }

        // Populate account dropdown for transaction detail filter with hierarchical structure
        function populateTransactionDetailAccountFilter(accounts) {

            const accountSelect = document.getElementById('td-account-filter');
            accountSelect.innerHTML = '';

            let selectOptions = [                             // category, value, textContent, color
                ['', '', 'All Accounts', 'black'],
                ['type:', 'asset', 'Assets', 'blue'],
                ['type:', 'liability', 'Liabilities', 'blue'],
                ['type:', 'equity', 'Equity', 'blue'],               
                ['type:', 'income', 'Income', 'blue'],
                ['type:', 'expense', 'Expenses', 'blue']               
            ];
 
            accounts[0].forEach(record => {
                if(record.parent_code == null) {
                    const option = ['parent:', record.account_code, record.account_name, , 'green']
                    selectOptions.push(option);
                } 
            });

            console.log('', selectOptions);

            selectOptions.forEach(line => {
                const option = document.createElement('option');
                option.value = line[0] + line[1];
                option.textContent = line[2];
                option.style.color = line[3];
                option.style.fontWeight = 'bold';
                accountSelect.appendChild(option);
            });
        }

        /******************************************************Balance Sheet Report**********************************************************/

        function updateBalanceSheetReport(accounts) {
            // Update Assets section
            const assetsBody = document.querySelector('#balance-sheet .grid-cols-2 > div:nth-child(1) .table tbody');
            // Update Liabilities & Equity section  
            const liabilitiesBody = document.querySelector('#balance-sheet .grid-cols-2 > div:nth-child(2) .table tbody');
            
            
            if (!assetsBody || !liabilitiesBody || !accounts || assetsBody === liabilitiesBody) {
                console.error('Balance Sheet elements issue:', {assetsBody, liabilitiesBody, accountsLength: accounts?.length});
                return;
            }

            // Filter accounts by type
            const assets = accounts.filter(acc => acc.account_type === 'asset');
            const liabilities = accounts.filter(acc => acc.account_type === 'liability');
            const equity = accounts.filter(acc => acc.account_type === 'equity');
            

            // Calculate totals using calculated balance field from Chart of Accounts API
            const totalAssets = assets.reduce((sum, acc) => sum + (parseFloat(acc.balance) || 0), 0);
            const totalLiabilities = liabilities.reduce((sum, acc) => sum + (parseFloat(acc.balance) || 0), 0);
            const totalEquity = equity.reduce((sum, acc) => sum + (parseFloat(acc.balance) || 0), 0);

            // Update Assets section
            let assetsHtml = `
                <tr style="font-weight: 600; background: #f0f9ff;">
                    <td>ASSETS</td>
                    <td style="text-align: right;"></td>
                </tr>
            `;
            
            if (assets.length === 0) {
                assetsHtml += `
                    <tr>
                        <td colspan="2" style="text-align: center; padding: 2rem; color: #6b7280;">
                            No asset accounts found
                        </td>
                    </tr>
                `;
            } else {
                assetsHtml += assets.map(account => `
                    <tr>
                        <td>&nbsp;&nbsp;${account.account_name}</td>
                        <td style="text-align: right;">${formatCurrency(parseFloat(account.balance) || 0)}</td>
                    </tr>
                `).join('') + `
                    <tr style="font-weight: 600; border-top: 2px solid #ddd; background: #f9fafb;">
                        <td>Total Assets</td>
                        <td style="text-align: right; color: var(--banking-blue);">${formatCurrency(totalAssets)}</td>
                    </tr>
                `;
            }
            assetsBody.innerHTML = assetsHtml;

            // Update Liabilities & Equity section
            let liabilitiesHtml = '';
            
            // Liabilities
            if (liabilities.length > 0) {
                liabilitiesHtml += `
                    <tr style="font-weight: 600; background: #fef2f2;">
                        <td>LIABILITIES</td>
                        <td style="text-align: right;"></td>
                    </tr>
                ` + liabilities.map(account => `
                    <tr>
                        <td>&nbsp;&nbsp;${account.account_name}</td>
                        <td style="text-align: right;">${formatCurrency(parseFloat(account.balance) || 0)}</td>
                    </tr>
                `).join('') + `
                    <tr style="font-weight: 600; border-bottom: 1px solid #ddd;">
                        <td>Total Liabilities</td>
                        <td style="text-align: right; color: var(--banking-red);">${formatCurrency(totalLiabilities)}</td>
                    </tr>
                    <tr style="height: 1rem;"><td colspan="2"></td></tr>
                `;
            }
            
            // Equity
            if (equity.length > 0) {
                liabilitiesHtml += `
                    <tr style="font-weight: 600; background: #f0f9ff;">
                        <td>EQUITY</td>
                        <td style="text-align: right;"></td>
                    </tr>
                ` + equity.map(account => `
                    <tr>
                        <td>&nbsp;&nbsp;${account.account_name}</td>
                        <td style="text-align: right;">${formatCurrency(parseFloat(account.balance) || 0)}</td>
                    </tr>
                `).join('') + `
                    <tr style="font-weight: 600; border-bottom: 1px solid #ddd;">
                        <td>Total Equity</td>
                        <td style="text-align: right; color: var(--banking-blue);">${formatCurrency(totalEquity)}</td>
                    </tr>
                    <tr style="height: 1rem;"><td colspan="2"></td></tr>
                `;
            }
            
            // Total Liabilities & Equity
            liabilitiesHtml += `
                <tr style="font-weight: 600; border-top: 2px solid #ddd; background: #f9fafb;">
                    <td>Total Liabilities & Equity</td>
                    <td style="text-align: right; color: var(--banking-blue);">${formatCurrency(totalLiabilities + totalEquity)}</td>
                </tr>
            `;
            
            if (liabilities.length === 0 && equity.length === 0) {
                liabilitiesHtml = `
                    <tr>
                        <td colspan="2" style="text-align: center; padding: 2rem; color: #6b7280;">
                            No liability or equity accounts found
                        </td>
                    </tr>
                `;
            }
            
            liabilitiesBody.innerHTML = liabilitiesHtml;
        }

        /**********************************************************TRANSACTION DETAIL REPORT****************************************************/

        let noFilter = false;
        async function updateTransactionDetailReport(transactions) {

            /****Create Doble Entry Transactions***/
            noFilter = false;
            const tbody = document.querySelector('#transactions-page .table tbody');
            if (!tbody) {
                console.error('Transaction detail tbody not found!');
                return;
            }

            if (!transactions || transactions.length === 0) {
                // console.log('No transactions to display, showing empty message');
                tbody.innerHTML = `
                    <tr>
                        <td colspan="5" style="text-align: center; padding: 2rem; color: #6b7280;">
                            No transactions found for the selected date range
                        </td>
                    </tr>
                `;
                return;
            }

            // Load accounts data for getAccountName function
            let fullAccountsData = [];
            window.fullAccountsData = fullAccountsData; // Make it globally accessible
            try {
                fullAccountsData = await getAccountsFromCache();
            } catch (error) {
                console.error('Failed to load accounts for transaction detail report:', error);
            }

            // Convert each transaction into proper double-entry format based on accounting rules
            const doubleEntryTransactions = [];

            let x = 0;
            transactions.forEach(transaction => {
                let amount = parseFloat(transaction.amount) || 0;
                const date = transaction.transaction_date;
                const reference = transaction.reference_number || '-';
                const description = transaction.description || '';
                const transactionType = transaction.transaction_type; // 'credit' or 'debit'

 
                const getMissingDetails = (transaction, fullAccountsData) => {
                    const fromAccount = fullAccountsData.find(acc => acc.id === transaction.from_account_id);
                    const toAccount = fullAccountsData.find(acc => acc.id === transaction.to_account_id);
                    if (!fromAccount || !toAccount) {
                        return null; // Handle cases where accounts aren't found
                    }
                    return {
                        from: { name: fromAccount.account_name, code: fromAccount.account_code, parent: fromAccount.parent_code, category: fromAccount.account_type },
                        to: { name: toAccount.account_name, code: toAccount.account_code, parent: toAccount.parent_code, category: toAccount.account_type }
                    };
                };

                const fromToDetails = getMissingDetails(transaction, fullAccountsData);
                const catNumber = {'asset': 1, 'liability': 2, 'equity': 3, 'income': 4, 'expense': 5};
                let cat = catNumber[fromToDetails.from.category];
                if(cat === 2 ) {
                    amount = transactionType === 'debit' ? amount : amount * -1;
                } else {
                    amount = transactionType === 'debit' ? amount * -1 : amount;
                }

                // Create Proper Double Entry Rows
                doubleEntryTransactions.push({
                    amount: amount,
                    id: transaction.id,
                    name: fromToDetails.from.name,                   
                    code: fromToDetails.from.code,
                    parent: fromToDetails.from.parent,
                    category: fromToDetails.from.category,        /* assets, liabilites, etc. */
                    counter: fromToDetails.to.name,
                    date: date,
                    description: description,
                    reference: reference,
                    dc: transactionType,
                    cat: cat                                     /* category number */
                });

                cat = catNumber[fromToDetails.to.category];
                doubleEntryTransactions.push({
                    amount: amount,
                    id: transaction.id,
                    name: fromToDetails.to.name,                   
                    code: fromToDetails.to.code,
                    parent: fromToDetails.to.parent,
                    category: fromToDetails.to.category,
                    counter: fromToDetails.from.name,
                    date: date,
                    description: description,
                    reference: reference,
                    dc: transactionType,
                    cat: cat
                });

            });

            doubleEntryTransactions.sort((a, b) => {
                // Sort by cat (category) 1. Assets, 2. Liabilities, etc.
                if (a.cat < b.cat) { return -1; };
                if (a.cat > b.cat) { return  1; };
                // When equal sort by parent
                if (a.parent < b.parent) { return -1; };
                if (a.parent > b.parent) { return  1; };
                // When equal sort by account_code
                if (a.code < b.code) { return -1; };
                if (a.code > b.code) { return  1; };
                // When equal sort by date
                if (a.date < b.date) { return -1; };
                if (a.date > b.date) { return  1; };
                // all equal
                return 0;
            });

            /****Filter by Category or Parent******/

            const currentAccountFilter = document.getElementById('td-account-filter')?.value;
            let filteredTransactions;

            if (currentAccountFilter) {
                if (currentAccountFilter.startsWith('type:')) {

                    // Filter by cat (category)
                    const filterAccountType = currentAccountFilter.replace('type:', '');
                    filteredTransactions = doubleEntryTransactions.filter(entry => {
                        return entry.category === filterAccountType;
                    });

                } else if (currentAccountFilter.startsWith('parent:')) {

                    // Filter by parent account code
                    const filterParentCode = currentAccountFilter.replace('parent:', '');
                    filteredTransactions = doubleEntryTransactions.filter(entry => {
                        return entry.parent === filterParentCode;
                    });
                    
                } 
            } else {
                filteredTransactions = doubleEntryTransactions;
            }

            /***************Create Groups******************/

            // Group entries cat, parent, child
            const groups = new Map();
            filteredTransactions.forEach(transaction => {

                // Create cat group and add to total
                if (!groups.has(transaction.cat)) {                     
                    groups.set(transaction.cat, {
                        group: "cat",
                        catCode: transaction.cat,
                        catTotal: 0
                    });
                };
                groups.get(transaction.cat).catTotal += transaction.amount;

                // Create parent group and add to total
                if (!groups.has(transaction.parent)) {                     
                    groups.set(transaction.parent, {
                        group: "parent",
                        parentCode: transaction.parent,
                        parentTotal: 0
                    });
                };
                groups.get(transaction.parent).parentTotal += transaction.amount;

                // Create code (account) group and add to total
                if (!groups.has(transaction.code)) {                     
                    groups.set(transaction.code, {
                        group: "code",
                        codeName: transaction.name,
                        codeCode: transaction.code,
                        codeTotal: 0,
                        transactions: []
                    });
                };
                groups.get(transaction.code).codeTotal += transaction.amount;
                groups.get(transaction.code).transactions.push(transaction);
                

            });

            /***********Build Report****************/

            let html = '';
            groups.forEach(group => {

                const catLabels = {'1': 'ASSETS', '2': 'LIABILITIES', '3': 'EQUITY', '4': 'INCOME', '5': 'EXPENSES' };
                if(group.group === "cat") {
                    // category header
                    html += `
                        <tr style="font-weight: 700; background: #1e40af; color: white; border-top: 3px solid #1e40af;">
                            <td colspan="4" style="padding: 1rem; font-size: 1.125rem; font-weight: 700; letter-spacing: 0.05em;">${catLabels[group.catCode]}</td>
                             <td style="padding: 0.75rem; text-align: right; font-weight: 700; font-size: 1rem; color: ${group.catTotal >= 0 ? 'var(--banking-green)' : 'var(--banking-red)'};">
                                ${group.catTotal >= 0 ? '+' : ''}${formatCurrency(Math.abs(group.catTotal))}
                            </td>
                            <td></td>                           
                        </tr>
                    `;
                }

                if(group.group === "parent") {

                    const parentCode = group.parentCode;
                    const getParentName = (parentCode, fullAccountsData) => {
                        const accounts = fullAccountsData.find(acc => acc.account_code === parentCode);
                        return accounts.account_name;
                    };
                    const parentName = getParentName(parentCode, fullAccountsData);

                    // parent header
                    html += `
                        <tr style="font-weight: 600; background: #f8fafc; border-left: 4px solid var(--banking-blue);">
                            <td style="padding: 0.75rem; font-weight: 600;">${group.parentCode}</td>
                            <td style="padding: 0.75rem; font-weight: 600; padding-left: 1.5rem;">${parentName}</td>
                            <td style="padding: 0.75rem;"></td>
                            <td style="padding: 0.75rem;"></td>
                            <td style="padding: 0.75rem; text-align: right; font-weight: 700; font-size: 1rem; color: ${group.parentTotal >= 0 ? 'var(--banking-green)' : 'var(--banking-red)'};">
                                ${group.parentTotal >= 0 ? '+' : ''}${formatCurrency(Math.abs(group.parentTotal))}
                            </td>
                            <td></td>     
                        </tr>
                    `;
                }

                if(group.group === "code") {

                    // code (account) header
                    html += `
                        <tr style="background: #f1f5f9; font-weight: 500;">
                            <td style="padding: 0.75rem; padding-left: 2rem; font-weight: 500;">${group.codeCode}</td>
                            <td style="padding: 0.75rem; padding-left: 2.5rem; font-weight: 500;">${group.codeName}</td>
                            <td style="padding: 0.75rem;"></td>
                            <td style="padding: 0.75rem;"></td>
                            <td style="padding: 0.75rem; text-align: right; font-weight: 600; color: ${group.codeTotal >= 0 ? 'var(--banking-green)' : 'var(--banking-red)'};">
                                ${group.codeTotal >= 0 ? '+' : ''}${formatCurrency(Math.abs(group.codeTotal))}
                            </td>
                            <td></td>                                 
                        </tr>
                    `;

                    // Individual transactions for this account
                    group.transactions.forEach(transaction => {
                        const amount = transaction.amount;
                        let displayColor = amount < 0 ? 'var(--banking-red)' : '#1f2937';
                        html += `
                            <tr style="border-bottom: 1px solid #f1f5f9; background: #fefefe;">
                                <td style="padding: 0.75rem; font-size: 0.875rem; color: #6b7280; padding-left: 3rem;">${formatDate(transaction.date)}</td>
                                <td style="padding: 0.75rem; font-size: 0.875rem; color: var(--banking-blue); padding-left: 3.5rem;">${transaction.counter}</td>
                                <td style="padding: 0.75rem; font-size: 0.875rem; color: #6b7280;">${transaction.reference}</td>
                                <td style="padding: 0.75rem; font-size: 0.875rem; color: #6b7280;">${transaction.description}</td>
                                <td style="padding: 0.75rem; font-size: 0.875rem; text-align: right; font-weight: 600; color: ${displayColor};">
                                    ${amount < 0 ? '(' : ''}${formatCurrency(Math.abs(amount))}${amount < 0 ? ')' : ''}
                                </td>
                                <td style="display: flex; gap: 0.5rem;">
                                    <button class="btn btn-secondary" style="padding: 0.25rem 0.5rem; font-size: 0.75rem;" onclick="noFilter = true; editTransactionFromPage('${transaction.id}');">Edit</button>
                                    <button class="btn btn-danger" style="padding: 0.25rem 0.5rem; font-size: 0.75rem;" onclick="noFilter = true; deleteTransaction('${transaction.id}');">Delete</button>
                                </td>
                            </tr>
                        `;
                    });
                };
            });

            tbody.innerHTML = html;
        };


        /***********************************************************ADMIN PANEL(PAGE) ***************************************************************/

        async function updateAdminPanel() {
            try {
                showLoading('admin-page');
                
                // Ensure we have a valid checkbook ID for admin panel
                if (!currentCheckbookId) {
                    console.warn('No checkbook selected - Admin Panel requires checkbook selection');
                }
                
                const [users, checkbooks, accounts] = await Promise.all([
                    loadUsers(),
                    loadCheckbooks(),
                    currentCheckbookId ? apiCall(`/accounts/checkbook/${currentCheckbookId}`) : Promise.resolve({ data: [] })
                ]);

                updateUsersTable(users);
                updateCheckbooksTable(checkbooks);
                
                // Normalize accounts response to handle both array and wrapped responses
                const accountsList = Array.isArray(accounts) ? accounts : (accounts?.data ?? []);
                updateAccountsTable(accountsList);
                
                hideLoading('admin-page');
            } catch (error) {
                console.error('Failed to update admin panel:', error);
                // Show error in admin accounts table
                const tbody = document.querySelector('#admin-accounts .table tbody');
                if (tbody) {
                    tbody.innerHTML = `
                        <tr>
                            <td colspan="8" style="text-align: center; padding: 2rem; color: #ef4444;">
                                Failed to load Chart of Accounts: ${error.message}
                            </td>
                        </tr>
                    `;
                }
                hideLoading('admin-page');
            }
        }

        function updateUsersTable(users) {
            const tbody = document.querySelector('#admin-users .table-container tbody');
            if (!tbody) {
                console.error('User table tbody not found');
                return;
            }
            // console.log('Updating users table with', users.length, 'users');

            tbody.innerHTML = users.map(user => `
                <tr>
                    <td>${user.username}</td>
                    <td><span class="badge ${user.user_role === 'admin' ? 'badge-danger' : 'badge-info'}">${user.user_role.charAt(0).toUpperCase() + user.user_role.slice(1)}</span></td>
                    <td>${user.checkbook_name}</td>
                    <td>${formatDate(user.created_at)}</td>
                    <td><span class="badge badge-success">Active</span></td>
                    <td>
                        <button class="btn btn-secondary" style="padding: 0.25rem 0.5rem; font-size: 0.75rem;" onclick="editUser('${user.id}')">Edit</button>
                        <button class="btn btn-danger" style="padding: 0.25rem 0.5rem; font-size: 0.75rem;" onclick="deleteUser('${user.id}')">Delete</button>
                    </td>
                </tr>
            `).join('');
        }

        async function updateCheckbooksTable(checkbooks) {
            // console.log('Updating checkbooks table with', checkbooks.length, 'checkbooks');
            // console.log('Full checkbooks array:', JSON.stringify(checkbooks, null, 2));
            const tbody = document.querySelector('#admin-checkbooks .table tbody');
            if (!tbody) {
                console.error('Checkbooks table tbody not found!');
                return;
            }
            
            // Display real statistics from the API
            tbody.innerHTML = checkbooks.map(checkbook => `
                <tr>
                    <td>${checkbook.checkbook_name}</td>
                    <td>${checkbook.user_count || 0}</td>
                    <td>${checkbook.account_count || 0}</td>
                    <td>${checkbook.transaction_count || 0}</td>
                    <td>${formatDate(checkbook.created_at)}</td>
                    <td><span class="badge ${checkbook.is_active ? 'badge-success' : 'badge-warning'}">${checkbook.is_active ? 'Active' : 'Inactive'}</span></td>
                    <td>
                        <button class="btn btn-secondary" style="padding: 0.25rem 0.5rem; font-size: 0.75rem;" onclick="editCheckbook('${checkbook.id}')">Edit</button>
                        <button class="btn btn-danger" style="padding: 0.25rem 0.5rem; font-size: 0.75rem;" onclick="deleteCheckbook('${checkbook.id}')">Delete</button>
                    </td>
                </tr>
            `).join('');
            
            // console.log('Checkbooks table updated successfully');
        }

        function updateAccountsTable(accounts) {
            const tbody = document.querySelector('#admin-accounts .table tbody');
            if (!tbody) {
                console.error('Admin accounts table tbody not found');
                return;
            }

            // Ensure accounts is an array
            const accountsArray = Array.isArray(accounts) ? accounts : [];
            // console.log('Updating admin Chart of Accounts with', accountsArray.length, 'accounts');
            
            if (accountsArray.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="8" style="text-align: center; padding: 2rem; color: #6b7280;">
                            ${currentCheckbookId ? 'No accounts found' : 'Please select a checkbook to view Chart of Accounts'}
                        </td>
                    </tr>
                `;
                return;
            }
            
            tbody.innerHTML = accountsArray.map(account => `
                <tr style="${account.parent_code ? '' : 'font-weight: 600; background: #f8fafc;'}">
                    <td>${account.account_code || ''}</td>
                    <td>${account.parent_code ? '&nbsp;&nbsp;' : ''}${account.account_name}</td>
                    <td>${account.account_type}</td>
                    <td>${account.parent_code || '-'}</td>
                    <td style="text-align: right;">${formatCurrency(Number(account.opening_balance || 0))}</td>
                    <td>${formatCurrency((account.account_balance || 0) + (account.opening_balance || 0))}</td>
                    <td><span class="badge ${account.is_active ? 'badge-success' : 'badge-warning'}">${account.is_active ? 'Active' : 'Inactive'}</span></td>
                    <td>
                        <button class="btn btn-secondary" style="padding: 0.25rem 0.5rem; font-size: 0.75rem;" onclick="editAccount('${account.id}')">Edit</button>
                        ${account.parent_code ? `<button class="btn btn-danger" style="padding: 0.25rem 0.5rem; font-size: 0.75rem;" onclick="deleteAccount('${account.id}')">Delete</button>` : ''}
                    </td>
                </tr>
            `).join('');
        }

        // Helper Functions
        // Use global account cache system instead of local cache

        function getAccountName(accountId) {
            const account = window.fullAccountsData?.find(acc => acc.id === accountId);
            return account ? account.account_name : (accountsCache[String(accountId)] || 'Unknown Account');
        }

        function getAccountIcon(accountName, accountType) {
            const name = accountName.toLowerCase();
            if (name.includes('checking') || name.includes('bank')) {
                return 'ðŸ¦'; // Bank icon
            }
            if (name.includes('cash')) {
                return 'ðŸ’°'; // Wallet icon
            }
            if (name.includes('investment') || name.includes('brokerage')) {
                return 'ðŸ“ˆ'; // Chart icon
            }
            if (name.includes('credit') || name.includes('card')) {
                return 'ðŸ’³'; // Credit card icon
            }
            if (name.includes('mortgage') || name.includes('loan')) {
                return 'ðŸ '; // House icon
            }
            
            // Fallback by account type
            const icons = {
                'asset': 'ðŸ’°',
                'liability': 'ðŸ’³',
                'income': 'ðŸ’µ',
                'expense': 'ðŸ’¸',
                'equity': 'ðŸ¦'
            };
            return icons[accountType] || 'ðŸ“Š';
        }

        function showLoading(containerId) {
            const container = document.getElementById(containerId);
            if (container) {
                container.style.opacity = '0.5';
                container.style.pointerEvents = 'none';
            }
        }

        function hideLoading(containerId) {
            const container = document.getElementById(containerId);
            if (container) {
                container.style.opacity = '1';
                container.style.pointerEvents = 'auto';
            }
        }

        /***********************************************************MORE MODAL FUNCTIONS***************************************************************/

        // Modal Functions
        async function openAddTransactionModal(accountId = null) {
            try {
                let account = null;
                if (accountId) {
                    account = await loadAccountById(accountId);
                }
                await populateAddTransactionModal(account, !!accountId);
                openModal('add-transaction-modal');
            } catch (error) {
                console.error('Error loading account for transaction modal:', error);
                showNotification('Failed to load account details', 'error');
            }
        }

        async function openTransactionListModal(accountId) {
            try {
                // Force reload of fresh data by bypassing cache
                const [account, transactions] = await Promise.all([
                    loadAccountById(accountId),
                    loadTransactionsByAccount(accountId)
                ]);
                // console.log('Transaction list modal - Account:', account);
                // console.log('Transaction list modal - Transactions:', transactions.length);
                
                // Store account ID in modal for deletion refresh
                const modal = document.getElementById('list-transactions-modal');
                if (modal) {
                    modal.setAttribute('data-account-id', accountId);
                }
                
                populateTransactionListModal(account, transactions);
                openModal('list-transactions-modal');
            } catch (error) {
                console.error('Error loading data for transaction list modal:', error);
                showNotification('Failed to load transaction data', 'error');
            }
        }

        async function openReconcileModal(accountId) {
            try {
                // Force reload of fresh data
                const [account, transactions] = await Promise.all([
                    loadAccountById(accountId),
                    loadTransactionsByAccount(accountId)
                ]);
                // console.log('Reconcile modal - Account:', account);
                // console.log('Reconcile modal - Transactions:', transactions.length);
                
                // Store account ID in modal for return navigation
                const reconcileModal = document.getElementById('reconcile-modal');
                if (reconcileModal) {
                    reconcileModal.setAttribute('data-account-id', accountId);
                }
                
                populateReconcileModal(account, transactions);
                openModal('reconcile-modal');
            } catch (error) {
                console.error('Error loading data for reconcile modal:', error);
                showNotification('Failed to load reconciliation data', 'error');
            }
        }

        // Edit transaction from Transaction List Modal - REMOVED DUPLICATE FUNCTION
        // This functionality is now handled by the main editTransaction function above
        
        // Edit transaction from Transactions page
        async function editTransactionFromPage(transactionId) {
            try {
                const transaction = await loadTransactionById(transactionId);
                
                // Store source in Edit modal for return navigation
                const editModal = document.getElementById('edit-transaction-modal');
                if (editModal) {
                    editModal.setAttribute('data-return-source', 'transactions-page');
                    editModal.removeAttribute('data-return-account-id'); // Clear any previous account ID
                }
                await populateEditTransactionModal(transaction);
                openModal('edit-transaction-modal');
            } catch (error) {
                console.error('Error opening edit transaction modal:', error);
                showNotification('Failed to load transaction for editing', 'error');
            }
        }

        async function deleteTransaction(transactionId) {
            try {
                const transaction = await loadTransactionById(transactionId);
                
                // Check if we're in the Transaction List Modal to track source
                const transactionListModal = document.getElementById('list-transactions-modal');
                const deleteModal = document.getElementById('delete-confirmation');
                
                if (transactionListModal && transactionListModal.classList.contains('active')) {
                    // Store the account ID for refreshing the Transaction List Modal
                    const accountId = transactionListModal.getAttribute('data-account-id');
                    if (accountId && deleteModal) {
                        deleteModal.setAttribute('data-return-source', 'transaction-list-modal');
                        deleteModal.setAttribute('data-return-account-id', accountId);
                    }
                } else if (deleteModal) {
                    // Clear any previous source tracking for transactions page
                    deleteModal.removeAttribute('data-return-source');
                    deleteModal.removeAttribute('data-return-account-id');
                }
                
                // Set up delete confirmation modal for transaction
                deleteModal.setAttribute('data-delete-type', 'transaction');
                deleteModal.setAttribute('data-delete-id', transactionId);
                
                // Populate transaction details
                const detailsDiv = document.getElementById('delete-item-details');
                detailsDiv.querySelector('div:first-child').textContent = 'Transaction to delete:';
                detailsDiv.querySelector('div:last-child').innerHTML = `
                    <strong>Date:</strong> ${formatDate(transaction.transaction_date)}<br>
                    <strong>Amount:</strong> ${formatCurrency(Math.abs(transaction.amount))}<br>
                    <strong>Description:</strong> ${transaction.description || 'No description'}
                `;
                
                openModal('delete-confirmation');
            } catch (error) {
                console.error('Error loading transaction for delete:', error);
                showNotification('Failed to load transaction details', 'error');
            }
        }
        
        async function confirmDeleteTransaction(transactionId) {
            if (!transactionId) {
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE_URL}/transactions/${transactionId}`, {
                    method: 'DELETE'
                });
                
                if (!response.ok) {
                    throw new Error('Failed to delete transaction');
                }
                
                showNotification('Transaction deleted successfully', 'success');
                
                // Check if we need to refresh the Transaction List Modal
                const deleteModal = document.getElementById('delete-confirmation');
                const returnSource = deleteModal ? deleteModal.getAttribute('data-return-source') : null;
                const returnAccountId = deleteModal ? deleteModal.getAttribute('data-return-account-id') : null;
                
                closeModal('delete-transaction-modal');
                
                // Refresh appropriate view
                if (returnSource === 'transaction-list-modal' && returnAccountId) {
                    // Refresh the Transaction List Modal
                    try {
                        await openTransactionListModal(returnAccountId);
                    } catch (error) {
                        console.error('Error refreshing transaction list modal:', error);
                    }
                } else {
                    // Default refresh for other pages
                    console.log('Passei por aqui... ', '4443');
                    await updateTransactions();
                    await updateDashboard();
                    
                }
            } catch (error) {
                console.error('Error deleting transaction:', error);
                showNotification('Failed to delete transaction', 'error');
            }
        }

        async function editUser(userId) {
            const modal = document.getElementById('user-modal');
            const title = modal.querySelector('.modal-title');
            const submitBtn = modal.querySelector('button[type="submit"]');
            
            title.textContent = 'Edit User Password';
            submitBtn.textContent = 'Update User';
            modal.setAttribute('data-mode', 'edit');
            modal.setAttribute('data-user-id', userId);
            
            // Populate checkbook dropdown first
            await populateCheckbookDropdown();
            
            // Load user data from the users array instead of API call
            try {
                const usersResponse = await fetch('/api/users');
                if (usersResponse.ok) {
                    const usersData = await usersResponse.json();
                    const users = usersData.data || [];
                    const user = users.find(u => u.id === userId);
                    
                    if (user) {
                        const form = modal.querySelector('form');
                        form.querySelector('[name="username"]').value = user.username || '';
                        form.querySelector('[name="user_role"]').value = user.user_role || 'user';
                        form.querySelector('[name="checkbook_id"]').value = user.checkbook_id || '';
                        // Don't populate password for security
                        form.querySelector('[name="password"]').value = '';
                    }
                }
            } catch (error) {
                console.error('Error loading user data:', error);
            }
            
            openModal('user-modal');
        }

        // Old stub function removed - using proper async editCheckbook function instead

        async function editAccount(accountId) {
            const modal = document.getElementById('account-modal');
            const title = modal.querySelector('.modal-title');
            const submitBtn = modal.querySelector('button[type="submit"]');
            const form = modal.querySelector('form');
            
            title.textContent = 'Edit Account';
            submitBtn.textContent = 'Update Account';
            modal.setAttribute('data-mode', 'edit');
            modal.setAttribute('data-account-id', accountId);
            
            // Parent code is now auto-calculated, no dropdown needed
            
            // Load account data and populate form
            try {
                const accounts = await getAccountsFromCache();
                const account = accounts.find(acc => acc.id === accountId);
                
                if (account) {
                    // Populate form fields with account data
                    form.querySelector('input[name="account_code"]').value = account.account_code || '';
                    form.querySelector('input[name="account_name"]').value = account.account_name || '';
                    form.querySelector('input[name="opening_balance"]').value = account.opening_balance || 0;
                    form.querySelector('textarea[name="description"]').value = account.account_description || '';
                    
                    // Set the account type dropdown
                    const typeSelect = form.querySelector('select[name="account_type"]');
                    if (typeSelect && account.account_type) {
                        typeSelect.value = account.account_type.toLowerCase();
                    }
                    
                    // Set the parent account dropdown
                    const parentSelect = form.querySelector('select[name="parent_code"]');
                    if (parentSelect && account.parent_code) {
                        // Find the parent option by matching the account code
                        const parentOption = Array.from(parentSelect.options).find(option => 
                            option.value === account.parent_code
                        );
                        if (parentOption) {
                            parentSelect.value = parentOption.value;
                        }
                    }
                } else {
                    console.error('Account not found:', accountId);
                    showNotification('Account not found', 'error');
                    return;
                }
            } catch (error) {
                console.error('Failed to load account data:', error);
                showNotification('Failed to load account data', 'error');
                return;
            }
            
            openModal('account-modal');
        }

        async function deleteUser(userId) {
            // Protect ROWID 1
            if (userId === 1 || userId === '1') {
                showNotification('This user cannot be deleted (protected system user)', 'error');
                return;
            }
            
            const details = document.querySelector('#delete-item-details > div:last-child');
            details.innerHTML = `
                <div><strong>Username:</strong> Loading...</div>
            `;
            
            // Load user data from users array to show in confirmation
            try {
                const usersResponse = await fetch('/api/users');
                if (usersResponse.ok) {
                    const usersData = await usersResponse.json();
                    const users = usersData.data || [];
                    const user = users.find(u => u.id === userId);
                    
                    if (user) {
                        details.innerHTML = `
                            <div><strong>Username:</strong> ${user.username}</div>
                            <div><strong>Role:</strong> ${user.user_role}</div>
                            <div><strong>Checkbook:</strong> ${user.checkbook_name}</div>
                        `;
                    }
                }
            } catch (error) {
                console.error('Error loading user for delete confirmation:', error);
            }
            
            const modal = document.getElementById('delete-confirmation');
            modal.setAttribute('data-delete-type', 'user');
            modal.setAttribute('data-delete-id', userId);
            
            openModal('delete-confirmation');
        }

        // Old stub function removed - using proper async deleteCheckbook function instead

        async function deleteAccount(accountId) {
            try {
                // Load account details for confirmation like we do for users/checkbooks
                const accounts = await getAccountsFromCache();
                const account = accounts.find(acc => acc.id === accountId);
                
                const details = document.querySelector('#delete-item-details > div:last-child');
                details.innerHTML = `
                    <div><strong>Account Code:</strong> ${account?.account_code || 'Unknown'}</div>
                    <div><strong>Account Name:</strong> ${account?.account_name || 'Unknown'}</div>
                    <div><strong>Account Type:</strong> ${account?.account_type || 'Unknown'}</div>
                    <div><strong>Current Balance:</strong> $${((account?.account_balance || 0) + (account?.opening_balance || 0)).toFixed(2)}</div>
                    <div style="color: #dc2626; font-weight: 500; margin-top: 0.5rem;">
                        âš ï¸ This action cannot be undone. All data will be permanently deleted.
                    </div>
                `;
                
                const modal = document.getElementById('delete-confirmation');
                modal.setAttribute('data-delete-type', 'account');
                modal.setAttribute('data-delete-id', accountId);
                
                openModal('delete-confirmation');
            } catch (error) {
                console.error('Error preparing account deletion:', error);
                showNotification('Failed to load account details', 'error');
            }
        }

        async function openAddUserModal() {
            const modal = document.getElementById('user-modal');
            const title = modal.querySelector('.modal-title');
            const submitBtn = modal.querySelector('button[type="submit"]');
            const form = modal.querySelector('form');
            
            title.textContent = 'Add New User';
            submitBtn.textContent = 'Add User';
            modal.setAttribute('data-mode', 'add');
            modal.removeAttribute('data-user-id');
            
            // Reset form completely
            form.reset();
            // Clear all field values explicitly
            form.querySelector('[name=\"username\"]').value = '';
            form.querySelector('[name=\"password\"]').value = '';
            form.querySelector('[name=\"user_role\"]').value = 'user';
            form.querySelector('[name=\"checkbook_id\"]').value = '';
            
            // Populate checkbook dropdown
            await populateCheckbookDropdown();
            
            openModal('user-modal');
        }

        async function populateCheckbookDropdown() {
            try {
                const response = await fetch('/api/checkbooks');
                if (!response.ok) throw new Error('Failed to fetch checkbooks');
                
                const data = await response.json();
                const checkbooks = data.data || [];
                
                const select = document.querySelector('#user-modal select[name="checkbook_id"]');
                if (select) {
                    // Clear existing options except the first one
                    select.innerHTML = '<option value="">Select a checkbook</option>';
                    
                    // Add checkbooks
                    checkbooks.forEach(checkbook => {
                        const option = document.createElement('option');
                        option.value = checkbook.id;
                        option.textContent = checkbook.checkbook_name;
                        select.appendChild(option);
                    });
                }
            } catch (error) {
                console.error('Error loading checkbooks:', error);
                showNotification('Failed to load checkbooks', 'error');
            }
        }

        function openAddCheckbookModal() {
            // console.log('openAddCheckbookModal called');
            const modal = document.getElementById('checkbook-modal');
            if (!modal) {
                console.error('checkbook-modal not found');
                return;
            }
            
            const title = modal.querySelector('.modal-title');
            const submitBtn = modal.querySelector('button[type="submit"]');
            const form = modal.querySelector('form');
            
            if (!title || !submitBtn || !form) {
                console.error('Modal elements not found:', {title, submitBtn, form});
                return;
            }
            
            title.textContent = 'Add New Checkbook';
            submitBtn.textContent = 'Add Checkbook';
            modal.setAttribute('data-mode', 'add');
            modal.removeAttribute('data-checkbook-id');
            
            // Reset form
            form.reset();
            // console.log('Opening add checkbook modal');
            
            openModal('checkbook-modal');
        }

        async function editCheckbook(checkbookId) {
            // console.log('editCheckbook called with ID:', checkbookId);
            try {
                const response = await apiCall(`/checkbooks/${checkbookId}`);
                // console.log('Edit checkbook API response:', response);
                const checkbook = response.data;
                
                const modal = document.getElementById('checkbook-modal');
                if (!modal) {
                    console.error('checkbook-modal not found for edit');
                    return;
                }
                
                const title = modal.querySelector('.modal-title');
                const submitBtn = modal.querySelector('button[type="submit"]');
                const form = modal.querySelector('form');
                
                if (!title || !submitBtn || !form) {
                    console.error('Edit modal elements not found:', {title, submitBtn, form});
                    return;
                }
                
                title.textContent = 'Edit Checkbook';
                submitBtn.textContent = 'Update Checkbook';
                modal.setAttribute('data-mode', 'edit');
                modal.setAttribute('data-checkbook-id', checkbookId);
                
                // Fill form with existing data
                const nameField = form.querySelector('input[name="checkbook_name"]');
                const descField = form.querySelector('input[name="description"]');
                
                // console.log('Form fields found:', {nameField, descField});
                // console.log('Checkbook data to populate:', checkbook);
                
                if (nameField) nameField.value = checkbook.checkbook_name || '';
                if (descField) descField.value = checkbook.description || '';
                
                // console.log('Opening edit checkbook modal');
                openModal('checkbook-modal');
            } catch (error) {
                console.error('Failed to load checkbook for editing:', error);
                showNotification('Failed to load checkbook details', 'error');
            }
        }

        async function deleteCheckbook(checkbookId) {
            // console.log('deleteCheckbook called with ID:', checkbookId);
            try {
                // Get checkbook details for confirmation
                const checkbooks = await loadCheckbooks();
                const checkbook = checkbooks.find(cb => cb.id === checkbookId);
                
                // Use the same professional modal as User management
                const details = document.querySelector('#delete-item-details > div:last-child');
                details.innerHTML = `
                    <div><strong>Checkbook:</strong> ${checkbook ? checkbook.checkbook_name : 'Unknown'}</div>
                    <div><strong>Description:</strong> ${checkbook?.description || 'None'}</div>
                    <div style="color: #dc2626; font-weight: 500; margin-top: 0.5rem;">
                        âš ï¸ This action cannot be undone. All data will be permanently deleted.
                    </div>
                `;
                
                const modal = document.getElementById('delete-confirmation');
                modal.setAttribute('data-delete-type', 'checkbook');
                modal.setAttribute('data-delete-id', checkbookId);
                
                openModal('delete-confirmation');
                
            } catch (error) {
                console.error('Error in deleteCheckbook:', error);
                showNotification('Failed to delete checkbook', 'error');
            }
        }

        async function populateParentAccountDropdown(modal) {
            try {
                const parentSelect = modal.querySelector('select[name="parent_code"]');
                if (!parentSelect) return;

                // Clear existing options except the first one (None)
                while (parentSelect.children.length > 1) {
                    parentSelect.removeChild(parentSelect.lastChild);
                }

                // Load all accounts to use as potential parents
                const accounts = await getAccountsFromCache();
                
                // Sort accounts by account code for logical order
                const accountsArray = Array.isArray(accounts) ? accounts : [];
                accountsArray.sort((a, b) => (a.account_code || '').localeCompare(b.account_code || ''));
                
                // Add each account as a potential parent
                accountsArray.forEach(account => {
                    const option = document.createElement('option');
                    option.value = account.account_code || account.id;
                    option.textContent = `${account.account_code || ''} - ${account.account_name}`;
                    parentSelect.appendChild(option);
                });
            } catch (error) {
                console.error('Failed to populate parent account dropdown:', error);
                // Don't show error to user, just leave the default option
            }
        }

        async function openAddAccountModal() {
            const modal = document.getElementById('account-modal');
            const title = modal.querySelector('.modal-title');
            const submitBtn = modal.querySelector('button[type="submit"]');
            const form = modal.querySelector('form');
            
            title.textContent = 'Add New Account';
            submitBtn.textContent = 'Add Account';
            modal.setAttribute('data-mode', 'add');
            modal.removeAttribute('data-account-id');
            
            // Reset form
            form.reset();
            
            // Parent code is now auto-calculated, no dropdown needed
            
            openModal('account-modal');
        }

        async function handleUserSubmit(form, modal) {
            const formData = new FormData(form);
            const mode = modal.getAttribute('data-mode');
            
            // Basic validation
            const username = formData.get('username');
            const checkbookId = formData.get('checkbook_id');
            const password = formData.get('password');
            const userRole = formData.get('user_role');
            
            if (!username || !checkbookId || !password || !userRole) {
                throw new Error('Please fill in all required fields');
            }
            
            if (mode === 'add') {
                // Get checkbook name from the dropdown
                const checkbookSelect = document.querySelector('#user-modal select[name="checkbook_id"]');
                const checkbookName = checkbookSelect.options[checkbookSelect.selectedIndex].text;
                
                // Generate UUID for new user
                const userId = crypto.randomUUID();
                
                // Create new user - use JSON format with all required fields
                const userData = {
                    id: userId,
                    username: username,
                    password: password,
                    user_role: userRole,
                    checkbook_id: checkbookId,
                    checkbook_name: checkbookName
                };
                
                console.log('Sending user data:', {
                    ...userData, password: '***'
                });
                
                const response = await fetch('/api/users', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(userData)
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('API Error Response:', errorText);
                    throw new Error(`Failed to create user: ${response.status}`);
                }
                
                const responseData = await response.json();
                if (responseData.status !== 'success') {
                    throw new Error(responseData.message || 'Failed to create user');
                }
                
                showNotification(`User "${username}" added successfully`, 'success');
            } else if (mode === 'edit') {
                // Update existing user
                const userId = modal.getAttribute('data-user-id');
                const checkbookSelect = document.querySelector('#user-modal select[name="checkbook_id"]');
                const checkbookName = checkbookSelect.options[checkbookSelect.selectedIndex].text;
                
                const userData = {
                    username: username,
                    password: password,
                    user_role: userRole,
                    checkbook_id: checkbookId,
                    checkbook_name: checkbookName
                };
                
                console.log('Updating user data:', {
                    ...userData, password: '***'
                });
                
                // Use apiCall function with correct syntax
                const responseData = await apiCall(`/users/${userId}`, 'PUT', userData);
                
                showNotification(`User "${username}" updated successfully`, 'success');
            }
            
            closeModal(modal.id);
            
            // Refresh user list if we're on admin page
            if (currentPage === 'admin') {
                await updateAdminPanel();
            }
        }

        async function handleCheckbookSubmit(form, modal) {
            // console.log('handleCheckbookSubmit called', {form, modal});
            const formData = new FormData(form);
            const mode = modal.getAttribute('data-mode');
            
            // console.log('Form mode:', mode);
            // console.log('Form data entries:', [...formData.entries()]);
            
            // Basic validation
            const checkbookName = formData.get('checkbook_name');
            const description = formData.get('description') || '';
            
            // console.log('Parsed form data:', {checkbookName, description});
            
            if (!checkbookName) {
                throw new Error('Please enter a checkbook name');
            }
            
            try {
                if (mode === 'add') {
                    // Create new checkbook
                    // console.log('Creating new checkbook...');
                    const response = await apiCall('/checkbooks', {
                        method: 'POST',
                        body: {
                            checkbook_name: checkbookName,
                            description: description
                        }
                    });
                    // console.log('Add response:', response);
                    showNotification(`Checkbook "${checkbookName}" added successfully`, 'success');
                } else if (mode === 'edit') {
                    // Update existing checkbook
                    const checkbookId = modal.getAttribute('data-checkbook-id');
                    // console.log('Updating checkbook ID:', checkbookId);
                    const response = await apiCall(`/checkbooks/${checkbookId}`, {
                        method: 'PUT',
                        body: {
                            checkbook_name: checkbookName,
                            description: description
                        }
                    });
                    // console.log('Edit response:', response);
                    showNotification(`Checkbook "${checkbookName}" updated successfully`, 'success');
                }
                
                // console.log('Closing modal and refreshing...');
                closeModal(modal.id);
                // Add a small delay to ensure database update is complete before refresh
                setTimeout(() => {
                    // console.log('Delayed refresh to get updated data...');
                    // Force a hard refresh by clearing any potential caches
                    updateAdminPanel();
                }, 1000);
            } catch (error) {
                console.error('Error in handleCheckbookSubmit:', error);
                throw new Error(`Failed to ${mode} checkbook: ${error.message}`);
            }
        }

        async function handleAccountSubmit(form, modal) {
            const formData = new FormData(form);
            const mode = modal.getAttribute('data-mode');
            const accountId = modal.getAttribute('data-account-id');
            
            // Ensure we have a checkbook ID
            if (!currentCheckbookId) {
                throw new Error('No checkbook selected. Please select a checkbook first.');
            }
            
            // Basic validation
            const accountCode = formData.get('account_code');
            const accountName = formData.get('account_name');
            const accountType = formData.get('account_type');
            const openingBalance = parseFloat(formData.get('opening_balance')) || 0;
            const description = formData.get('description') || '';
            
            // Debug form data collection
            // console.log('Form data collected:', {
            //     accountCode,
            //     accountName,
            //     accountType,
            //     openingBalance,
            //     description,
            //     currentCheckbookId
            // });
            
            if (!accountCode || !accountName || !accountType) {
                throw new Error('Please enter account code, name, and select account type');
            }
            
            // Auto-calculate parent code from first two digits + 00
            let parentCode = null;
            if (accountCode && accountCode.length >= 2) {
                const firstTwoDigits = accountCode.substring(0, 2);
                parentCode = firstTwoDigits + '00';
                // Don't set parent if it would be the same as the account code
                if (parentCode === accountCode) {
                    parentCode = null;
                }
            }
            
            // Prepare account data with exact API field names
            const accountData = {
                account_code: accountCode,
                account_name: accountName,
                account_type: accountType,
                opening_balance: openingBalance,
                parent_code: parentCode,
                account_description: description,
                checkbook_id: currentCheckbookId,
                is_active: 1
            };
            
            // Debug what we're actually sending to API
            // console.log('Sending to API:', accountData);
            
            try {
                let response;
                if (mode === 'edit' && accountId) {
                    // Update existing account
                    response = await apiCall(`/accounts/${accountId}`, {
                        method: 'PUT',
                        body: accountData
                    });
                } else {
                    // Create new account
                    response = await apiCall('/accounts', {
                        method: 'POST',
                        body: accountData
                    });
                }
                
                // console.log('Account API response:', response);
                showNotification(`Account "${accountCode} - ${accountName}" ${mode === 'edit' ? 'updated' : 'added'} successfully`, 'success');
                
                // Invalidate account cache since account data changed
                invalidateAccountsCache(`Account ${mode === 'edit' ? 'updated' : 'created'}: ${accountName}`);
                
                closeModal(modal.id);
                
                // Refresh all relevant sections immediately
                setTimeout(() => {
                    if (currentPage === 'admin') {
                        updateAdminPanel();
                    }
                    if (currentPage === 'assets-liabilities') {
                        updateAssetsLiabilitiesPage();
                    }
                    if (currentPage === 'transactions') {
                        console.log('Passei por aqui... ', '5060');
                        updateTransactionsPage();
                    }
                    if (currentPage === 'reports') {
                        updateReportsPage();
                    }
                }, 300);
                
            } catch (error) {
                console.error('Failed to save account:', error);
                throw new Error(`Failed to ${mode === 'edit' ? 'update' : 'create'} account: ${error.message}`);
            }
        }

        async function handleDeleteConfirmation() {
            const modal = document.getElementById('delete-confirmation');
            const deleteType = modal.getAttribute('data-delete-type');
            const deleteId = modal.getAttribute('data-delete-id');
            
            if (!deleteType || !deleteId) {
                showNotification('Delete operation failed - missing information', 'error');
                closeModal('delete-confirmation');
                return;
            }
            
            // Handle different delete types
            if (deleteType === 'transaction') {
                try {
                    const response = await fetch(`${API_BASE_URL}/transactions/${deleteId}`, {
                        method: 'DELETE'
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to delete transaction');
                    }
                    
                    showNotification('Transaction deleted successfully', 'success');
                    
                    // Check if we need to refresh the Transaction List Modal
                    const returnSource = modal.getAttribute('data-return-source');
                    const returnAccountId = modal.getAttribute('data-return-account-id');
                    
                    closeModal('delete-confirmation');
                    
                    // Refresh appropriate view
                    if (returnSource === 'transaction-list-modal' && returnAccountId) {
                        // Refresh Transaction List Modal
                        await openTransactionListModal(returnAccountId);
                    } else {
                        // Refresh main data views
                        await updateDashboard();
                        if (currentPage === 'assets-liabilities') {
                            await updateAssetsLiabilities();
                        } else if (currentPage === 'transactions') {
                            console.log('Passei por aqui... ', '5114');
                            await updateTransactions();
                        } else {
                            await updateTransactionDetailPeriod();
                        }
                    }
                } catch (error) {
                    console.error('Error deleting transaction:', error);
                    showNotification('Failed to delete transaction', 'error');
                }
            } else if (deleteType === 'user') {
                try {
                    const response = await fetch(`/api/users/${deleteId}`, {
                        method: 'DELETE'
                    });
                    
                    if (response.ok) {
                        showNotification('User deleted successfully', 'success');
                        // Refresh user list if we're on admin page
                        if (currentPage === 'admin') {
                            await updateAdminPanel();
                        }
                    } else {
                        const errorData = await response.json();
                        showNotification(errorData.message || 'Failed to delete user', 'error');
                    }
                } catch (error) {
                    console.error('Error deleting user:', error);
                    showNotification('Failed to delete user', 'error');
                }
            } else if (deleteType === 'checkbook') {
                try {
                    console.log('Deleting checkbook with ID:', deleteId);
                    const response = await apiCall(`/checkbooks/${deleteId}`, 'DELETE');
                    // console.log('Delete API response:', response);
                    showNotification('Checkbook deleted successfully', 'success');
                    
                    // Refresh admin panel if we're on admin page
                    if (currentPage === 'admin') {
                        setTimeout(() => {
                            updateAdminPanel();
                        }, 500);
                    }
                } catch (error) {
                    console.error('Error deleting checkbook:', error);
                    showNotification('Failed to delete checkbook', 'error');
                }
            } else if (deleteType === 'account') {
                try {
                    // console.log('Deleting account with ID:', deleteId);
                    const response = await apiCall(`/accounts/${deleteId}`, 'DELETE');
                    // console.log('Delete account API response:', response);
                    
                    // Invalidate account cache since account was deleted
                    invalidateAccountsCache('Account deleted');
                    
                    showNotification('Account deleted successfully', 'success');
                    
                    // Refresh admin panel if we're on admin page
                    if (currentPage === 'admin') {
                        setTimeout(() => {
                            updateAdminPanel();
                        }, 500);
                    }
                } catch (error) {
                    console.error('Error deleting account:', error);
                    showNotification('Failed to delete account', 'error');
                }
            } else {
                // For other types, show not implemented message
                showNotification(`${deleteType} deletion not implemented yet`, 'info');
            }
            
            closeModal('delete-confirmation');
        }

        async function loadUserManagementData() {
            try {
                const response = await fetch('/api/users');
                if (!response.ok) throw new Error('Failed to fetch users');
                
                const data = await response.json();
                const users = data.data || [];
                
                // Find the user management table body
                const tableBody = document.querySelector('#admin .card:first-child .table-container tbody');
                if (!tableBody) return;
                
                // Clear existing rows
                tableBody.innerHTML = '';
                
                // Add user rows
                users.forEach(user => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${user.username}</td>
                        <td>${user.checkbook_name || 'Unknown'}</td>
                        <td><span class="badge ${user.user_role === 'admin' ? 'badge-warning' : 'badge-info'}">${user.user_role}</span></td>
                        <td><span class="badge badge-success">Active</span></td>
                        <td>
                            <div style="display: flex; gap: 0.5rem;">
                                <button class="btn btn-sm btn-secondary" onclick="editUser('${user.id}')">Edit</button>
                                <button class="btn btn-sm btn-danger" onclick="deleteUser('${user.id}')">Delete</button>
                            </div>
                        </td>
                    `;
                    tableBody.appendChild(row);
                });
                
                if (users.length === 0) {
                    tableBody.innerHTML = '<tr><td colspan="5" style="text-align: center; padding: 2rem; color: #6b7280;">No users found</td></tr>';
                }
                
            } catch (error) {
                console.error('Error loading users:', error);
                showNotification('Failed to load users', 'error');
            }
        }

        /***********************************************************INITIATE APP & LOGIN PAGE***********************************************/

        // Initialize Application
        document.addEventListener('DOMContentLoaded', async function() {
            await populateLoginCheckbooks();
            showLogin();
            // Data will be loaded after successful login
        });

        // Page Navigation
        function showLogin() {
            document.getElementById('login-page').classList.add('active');
            document.getElementById('app-layout').classList.remove('active');
        }

        function showApp() {
            document.getElementById('login-page').classList.remove('active');
            document.getElementById('app-layout').classList.add('active');
        }

        async function showPage(pageId) {
            // Check admin access for admin page
            if (pageId === 'admin' && currentUser && currentUser.user_role !== 'admin') {
                showNotification('Access denied. Admin privileges required.', 'error');
                return;
            }
            
            // Hide all pages
            document.querySelectorAll('.main-content .page').forEach(page => {
                page.classList.remove('active');
            });
            
            // Show selected page
            document.getElementById(pageId + '-page').classList.add('active');
            currentPage = pageId;

            // Load data for the specific page
            switch (pageId) {
                case 'dashboard':
                    await updateDashboard();
                    break;
                case 'assets-liabilities':
                    await updateAssetsLiabilities();
                    break;
                case 'transactions':
                    console.log('Passei por aqui... ', '5278');
                    await updateTransactions();
                    break;
                case 'reports':
                    await updateReports();
                    break;
                case 'admin':
                    await updateAdminPanel();
                    break;
            }
        }

        function setActiveNavItem(element) {
            // Remove active class from all nav items
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // Add active class to clicked item
            element.classList.add('active');
        }

        // Tab Navigation
        function setActiveTab(element, tabId) {
            // Get the tab container
            const tabContainer = element.closest('.tabs').nextElementSibling.parentElement;
            
            // Remove active class from all tabs in this container
            element.closest('.tab-list').querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Hide all tab contents in this container
            tabContainer.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Add active class to clicked tab
            element.classList.add('active');
            
            // Show selected tab content
            document.getElementById(tabId).classList.add('active');
        }

        // Modal System
        function openModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.classList.add('active');
                document.body.style.overflow = 'hidden';
            }
        }

        function closeModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.classList.remove('active');
                document.body.style.overflow = 'auto';
            }
        }

        // Close modal when clicking overlay
        document.querySelectorAll('.modal-overlay').forEach(overlay => {
            overlay.addEventListener('click', function(e) {
                if (e.target === this) {
                    closeModal(this.id);
                }
            });
        });

        // Close modal on Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                document.querySelectorAll('.modal-overlay.active').forEach(modal => {
                    closeModal(modal.id);
                });
            }
        });

        // Switch Toggle
        function toggleSwitch(switchElement) {
            switchElement.classList.toggle('active');
        }

        // Populate checkbooks on page load
        async function populateLoginCheckbooks() {
            try {
                const checkbooks = await loadCheckbooks();
                const select = document.getElementById('login-checkbook-select');
                if (select && checkbooks.length > 0) {
                    select.innerHTML = '<option value="">Select checkbook</option>' +
                        checkbooks.map(cb => `<option value="${cb.id}">${cb.checkbook_name}</option>`).join('');
                }
            } catch (error) {
                console.error('Failed to load checkbooks for login:', error);
            }
        }

        // Form Handling
        async function handleLogin(event) {
            event.preventDefault();
            
            // Get form values
            const form = event.target;
            const formData = new FormData(form);
            const username = formData.get('username');
            const password = formData.get('password');
            const checkbookId = formData.get('checkbook');
            
            // Debug: Log what we're sending to the API
            console.log('Login attempt:', {
                username: username,
                password: password ? '[PRESENT]' : '[MISSING]',
                checkbook_id: checkbookId
            });
            
            // Validate required fields
            if (!username || !password || !checkbookId) {
                showNotification('Please fill in all fields including checkbook selection', 'error');
                return;
            }
            
            try {
                // Show loading state
                const submitBtn = form.querySelector('button[type="submit"]');
                const originalText = submitBtn.textContent;
                submitBtn.textContent = 'Signing In...';
                submitBtn.disabled = true;

                // Load checkbooks to get the selected one
                const checkbooks = await loadCheckbooks();
                const selectedCheckbook = checkbooks.find(cb => cb.id === checkbookId);
                if (!selectedCheckbook) {
                    throw new Error('Selected checkbook not found');
                }
                
                // Use the authentication endpoint for login
                const authResponse = await fetch('/api/auth/login', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        username: username,
                        password: password,
                        checkbook_id: checkbookId
                    })
                });
                
                if (!authResponse.ok) {
                    const errorData = await authResponse.json();
                    console.log('Authentication failed:', errorData.message);
                    throw new Error(errorData.message || 'Invalid credentials');
                }
                
                const authResult = await authResponse.json();
                const authenticatedUser = authResult.data;
                // console.log('Authentication successful for user:', authenticatedUser.username);
                currentUser = {
                    id: authenticatedUser.id,
                    username: authenticatedUser.username,
                    user_role: authenticatedUser.user_role,
                    checkbook_id: authenticatedUser.checkbook_id
                };
                currentCheckbookId = checkbookId;
                
                // Clear account cache when switching checkbooks
                invalidateAccountsCache('Switched to different checkbook');
                
                // Pre-load accounts into cache for immediate use
                await getAccountsFromCache();

                // Update sidebar with checkbook name
                const sidebarCheckbook = document.querySelector('.sidebar-header p');
                if (sidebarCheckbook) {
                    sidebarCheckbook.textContent = selectedCheckbook?.checkbook_name || 'Unknown Checkbook';
                }

                // Update navigation based on user role
                const adminNavItem = document.getElementById('admin-nav-item');
                if (adminNavItem) {
                    if (currentUser.user_role === 'admin') {
                        adminNavItem.style.display = 'block';
                    } else {
                        adminNavItem.style.display = 'none';
                    }
                }
                
                // Show app and load dashboard
                showApp();
                await showPage('dashboard');
                
            } catch (error) {
                console.error('Login failed:', error);
                showNotification(error.message || 'Login failed', 'error');
            } finally {
                // Reset button state
                const submitBtn = form.querySelector('button[type="submit"]');
                submitBtn.textContent = 'Sign In';
                submitBtn.disabled = false;
            }
        }

        /***********************************************************MODAL SUBMIT HANDLE*****************************************/

        async function handleSubmit(event) {
            event.preventDefault();
            const form = event.target;
            const modal = form.closest('.modal-overlay');
            const submitter = event.submitter; // Get which button was clicked
            
            if (modal) {
                try {
                    // Handle different modal types
                    if (modal.id === 'add-transaction-modal') {
                        await handleAddTransactionSubmit(form);
                        
                        // Check if this was "Next" or "Exit" button
                        if (submitter && submitter.value === 'next') {
                            // For "Next": Reset form but keep modal open
                            form.reset();
                            // Set today's date as default
                            const dateField = form.querySelector('[name="date"]');
                            if (dateField) {
                                const today = new Date();
                                const year = today.getFullYear();
                                const month = String(today.getMonth() + 1).padStart(2, '0');
                                const day = String(today.getDate()).padStart(2, '0');
                                dateField.value = `${year}-${month}-${day}`;
                            }
                            
                            // Refresh the account balance in the modal if there's a preset account
                            const accountId = modal.getAttribute('data-account-id');
                            if (accountId) {
                                try {
                                    const account = await loadAccountById(accountId);
                                    if (account && account.data) {
                                        // Update the balance display in the modal
                                        const infoItems = modal.querySelectorAll('#from-account-info .info-item');
                                        if (infoItems.length >= 2) {
                                            const balanceValue = infoItems[1].querySelector('.info-value');
                                            if (balanceValue) {
                                                const currentBalance = (account.data.account_balance || 0) + (account.data.opening_balance || 0);
                                                const formattedBalance = formatCurrency(currentBalance);
                                                balanceValue.textContent = formattedBalance;
                                                balanceValue.style.color = currentBalance >= 0 ? 'var(--banking-green)' : 'var(--banking-red)';
                                            }
                                        }
                                    }
                                } catch (error) {
                                    console.error('Error refreshing account balance:', error);
                                }
                            }
                            
                            // Keep modal open, don't close it
                            showNotification('Transaction added! Add another transaction.', 'success');
                        } else {
                            // For "Exit": Reset form completely and close modal
                            const returnAccountId = modal.getAttribute('data-return-account-id');
                            const returnSource = modal.getAttribute('data-return-source');
                            
                            // Reset form completely
                            form.reset();
                            // Clear any data attributes
                            modal.removeAttribute('data-account-id');
                            modal.removeAttribute('data-return-account-id');
                            modal.removeAttribute('data-return-source');
                            
                            closeModal(modal.id);
                            showNotification('Transaction added successfully', 'success');
                            
                            // Handle return to source modal
                            if (returnSource === 'reconcile-modal' && returnAccountId) {
                                try {
                                    await openReconcileModal(returnAccountId);
                                } catch (error) {
                                    console.error('Error reopening reconcile modal:', error);
                                }
                            } else if (returnSource === 'transaction-list-modal' && returnAccountId) {
                                try {
                                    await openTransactionListModal(returnAccountId);
                                } catch (error) {
                                    console.error('Error reopening transaction list modal:', error);
                                }
                            }
                        }
                    } else if (modal.id === 'edit-transaction-modal') {
                        await handleEditTransactionSubmit(form);
                        closeEditTransactionModal();

                    } else if (modal.id === 'reconcile-modal') {
                        await handleReconcileSubmit(form);
                        closeModal(modal.id);
                    } else {
                        // Handle admin forms
                        if (modal.id === 'user-modal') {
                            await handleUserSubmit(form, modal);
                        } else if (modal.id === 'checkbook-modal') {
                            await handleCheckbookSubmit(form, modal);
                        } else if (modal.id === 'account-modal') {
                            await handleAccountSubmit(form, modal);
                        } else {
                            // Unhandled form - do not show fake success
                            console.warn('Unhandled form submission for modal:', modal.id);
                            closeModal(modal.id);
                        }
                    }
                    
                    // Refresh relevant data after any transaction operation
                    if (modal.id.includes('transaction')) {
                        console.log('Passei por aqui... ', '5588');
                        //await updateTransactions();
                        await updateDashboard();
                    }
                } catch (error) {
                    console.error('Error submitting form:', error);
                    showNotification(error.message || 'Failed to submit form', 'error');
                }
            }
        }

        async function handleAddTransactionSubmit(form) {
            const formData = new FormData(form);
            const modal = form.closest('.modal-overlay');
            const accountId = modal.getAttribute('data-account-id');
            
            const transactionData = {
                transaction_date: formData.get('date'),
                description: formData.get('description') || '', // Store blank instead of null
                amount: parseFloat(formData.get('amount')),
                transaction_type: formData.get('transaction_type'),
                from_account_id: formData.get('fromAccount') || accountId, // Use selected fromAccount or fallback to preset account
                to_account_id: formData.get('toAccount'),
                reference_number: formData.get('referenceNumber') || '', // Store blank instead of null
                checkbook_id: currentCheckbookId
            };
            
            
            // Validation
            if (!transactionData.transaction_date) {
                throw new Error('Transaction date is required');
            }
            // Get the selected account to check if it's "Other"
            const accounts = await getAccountsFromCache();
            const toAccount = accounts.find(acc => acc.id === transactionData.to_account_id);
            const isOtherAccount = toAccount && (toAccount.account_name.toLowerCase().includes('other') || toAccount.account_code === 'OTHER');
            
            // Only require description if the "To Account" indicates "Other"
            if (isOtherAccount && !transactionData.description) {
                throw new Error('Transaction description is required when using "Other" account');
            }
            if (!transactionData.amount || isNaN(transactionData.amount) || transactionData.amount <= 0) {
                throw new Error('Valid transaction amount is required (must be greater than 0)');
            }
            if (!transactionData.transaction_type) {
                throw new Error('Transaction type is required');
            }
            if (!transactionData.from_account_id) {
                throw new Error('From account is required - please select an account');
            }
            if (!transactionData.to_account_id) {
                throw new Error('To account is required');
            }
            if (!transactionData.checkbook_id) {
                throw new Error('Checkbook ID is required');
            }
            
            const response = await fetch(`${API_BASE_URL}/transactions`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(transactionData)
            });
            
            if (!response.ok) {
                const errorText = await response.text();
                console.error('API Error Response:', errorText);
                throw new Error(`Failed to create transaction: ${response.status} - ${errorText}`);
            }
            
            showNotification('Transaction added successfully', 'success');
            
            // console.log('Transaction added - refreshing all data...');
            
            // Always refresh dashboard to update account balances
            await updateDashboard();
            // console.log('Dashboard updated');
            
            // Refresh the data on the current page
            if (currentPage === 'assets-liabilities') {
                await updateAssetsLiabilities();
                // console.log('Assets & Liabilities updated');
            } else if (currentPage === 'transactions') 
            {   console.log('Passei por aqui... ', '5672');
                await updateTransactions();
                // console.log('Transactions page updated');
            } else if (currentPage === 'dashboard') {
                // If on dashboard, update it again to ensure balance cards are fresh
                await updateDashboard();
                // console.log('Dashboard re-updated');
            }
            
            // Force refresh any open modals that might show account balances
            const openModals = document.querySelectorAll('.modal-overlay[style*="flex"]');
            if (openModals.length > 0) {
                // console.log('Refreshing open modals...');
                // Close and reopen any account-specific modals to refresh their data
                openModals.forEach(modal => {
                    if (modal.id === 'transaction-list-modal' || modal.id === 'reconcile-modal') {
                        const accountId = modal.getAttribute('data-account-id');
                        if (accountId) {
                            closeModal(modal.id);
                            setTimeout(() => {
                                if (modal.id === 'transaction-list-modal') {
                                    openTransactionListModal(accountId);
                                } else if (modal.id === 'reconcile-modal') {
                                    openReconcileModal(accountId);
                                }
                            }, 100);
                        }
                    }
                });
            }
        }

        async function handleEditTransactionSubmit(form) {
            const formData = new FormData(form);
            const modal = form.closest('.modal-overlay');
            const transactionId = modal.getAttribute('data-transaction-id');
            
            if (!transactionId) {
                throw new Error('Transaction ID not found');
            }
            
            // Debug: Check what form data we're getting
            // console.log('Edit form data:');
            for (let [key, value] of formData.entries()) {
                console.log(`${key}: ${value}`);
            }
            
            const transactionData = {
                transaction_date: formData.get('date'),
                description: formData.get('description') || '', // Store blank instead of null
                amount: parseFloat(formData.get('amount')),
                transaction_type: formData.get('transaction_type'),
                from_account_id: formData.get('fromAccount'),
                to_account_id: formData.get('toAccount'),
                reference_number: formData.get('referenceNumber') || '' // Store blank instead of null
            };
            
            // console.log('Transaction data being sent:', transactionData);
            
            // Validate required fields before sending
            if (!transactionData.transaction_type) {
                throw new Error('Transaction type is required - please select Debit or Credit');
            }
            if (!transactionData.transaction_date) {
                throw new Error('Transaction date is required');
            }
            if (!transactionData.from_account_id) {
                throw new Error('From account is required');
            }
            if (!transactionData.amount || isNaN(transactionData.amount) || transactionData.amount <= 0) {
                throw new Error('Valid amount is required');
            }
            
            const response = await fetch(`${API_BASE_URL}/transactions/${transactionId}`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(transactionData)
            });
            
            if (!response.ok) {
                throw new Error('Failed to update transaction');
            }
            
            showNotification('Transaction updated successfully', 'success');
            
            // console.log('Transaction updated - refreshing all data...');
            
            // Always refresh dashboard to update account balances
            await updateDashboard();
            // console.log('Dashboard updated');
            
            // Refresh the data on the current page
            if (currentPage === 'assets-liabilities') {
                await updateAssetsLiabilities();
                // console.log('Assets & Liabilities updated');
            } else if (currentPage === 'transactions') {
                console.log('Passei por aqui... ', '5770');
                await updateTransactions();
                // console.log('Transactions page updated');
            } else if (currentPage === 'dashboard') {
                await updateDashboard();
                // console.log('Dashboard re-updated');
            } else {
                await updateTransactionDetailPeriod();
            }
        }

        async function handleReconcileSubmit(form) {
            
            // Validate required fields first
            const formData = new FormData(form);
            const statementDate = formData.get('statementDate');
            const statementBalance = formData.get('statementBalance');
            
            if (!statementDate) {
                showNotification('Statement date is required', 'error');
                return;
            }
            
            if (!statementBalance || isNaN(parseFloat(statementBalance))) {
                showNotification('Valid statement balance is required', 'error');
                return;
            }
            
            // Get checked transactions
            const modal = form.closest('.modal-overlay');
            const checkboxes = modal.querySelectorAll('input[type="checkbox"]:checked:not(#toggle-mark-unmark)');
            const transactionIds = Array.from(checkboxes)
                .map(cb => cb.getAttribute('data-transaction-id'))
                .filter(id => id); // Remove any null/undefined values
            
            
            if (transactionIds.length === 0) {
                showNotification('No transactions selected for reconciliation', 'warning');
                return;
            }
            
            // Verify reconciliation is balanced before proceeding
            const differenceEl = document.getElementById('reconcile-difference');
            const differenceText = differenceEl?.textContent || '$0.00';
            const difference = Math.abs(parseFloat(differenceText.replace(/[$,]/g, '')));
            
            if (difference >= 0.01) {
                showNotification('Cannot complete reconciliation - accounts are not balanced', 'error');
                return;
            }
            
            try {
                // Get form data for reconciliation record
                const accountId = modal.getAttribute('data-account-id');
                const statementBalance = parseFloat(formData.get('statementBalance') || 0);
                const statementDate = formData.get('statementDate');
                
                // Calculate totals from selected transactions
                let totalDebits = 0;
                let totalCredits = 0;
                checkboxes.forEach(checkbox => {
                    const amount = Math.abs(parseFloat(checkbox.dataset.amount) || 0);
                    if (checkbox.dataset.type === 'credit') {
                        totalCredits += amount;
                    } else {
                        totalDebits += amount;
                    }
                });
                
                // Create reconciliation record matching the database schema exactly
                const reconciliationData = {
                    checkbook_id: currentCheckbookId,
                    account_id: accountId,
                    statement_date: statementDate,
                    statement_balance: parseFloat(statementBalance),
                    reconciled_balance: parseFloat(statementBalance),
                    difference: 0.0 // Should be 0 when reconciliation is complete
                };
                
                
                
                // Mark transactions as reconciled first (this is the most important part)
                const transactionPromises = await Promise.all(
                    transactionIds.map(id => 
                        fetch(`${API_BASE_URL}/transactions/${id}/reconcile`, {
                            method: 'PUT'
                        })
                    )
                );
                
                // Check if any transaction reconciliation failed
                const failedTransactions = transactionPromises.filter(response => !response.ok);
                if (failedTransactions.length > 0) {
                    throw new Error(`Failed to reconcile ${failedTransactions.length} transactions`);
                }
                
                // Save reconciliation record (essential for history tracking)
                const reconcileResponse = await fetch(`${API_BASE_URL}/reconciliations`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(reconciliationData)
                });
                
                if (!reconcileResponse.ok) {
                    const errorDetails = await reconcileResponse.text();
                    console.error('Failed to save reconciliation record:', errorDetails);
                    
                    // Still show warning but don't fail since transactions were reconciled
                    showNotification('Transactions reconciled, but could not save reconciliation record.', 'warning');
                }
                
                showNotification(`Reconciliation completed successfully! ${transactionIds.length} transactions reconciled.`, 'success');
                
                // Refresh dashboard and assets/liabilities after reconciliation
                await updateDashboard();
                if (currentPage === 'assets-liabilities') {
                    await updateAssetsLiabilities();
                }
                
            } catch (error) {
                console.error('Reconciliation error:', error);
                showNotification(error.message || 'Failed to complete reconciliation', 'error');
            }
        }

        function logout() {
            // Clear password field but keep username and checkbook selection
            const passwordField = document.querySelector('#login-page input[name="password"]');
            if (passwordField) {
                passwordField.value = '';
            }
            
            showLogin();
        }

        // Form Interactions
        document.addEventListener('DOMContentLoaded', function() {
            // Radio button groups
            document.querySelectorAll('input[type="radio"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    // Uncheck other radios in the same group
                    const name = this.name;
                    document.querySelectorAll(`input[type="radio"][name="${name}"]`).forEach(other => {
                        if (other !== this) {
                            other.checked = false;
                        }
                    });
                });
            });

            // Checkbox interactions for transaction type
            document.querySelectorAll('input[type="checkbox"][id*="debit"], input[type="checkbox"][id*="credit"]').forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    if (this.id.includes('debit') && this.checked) {
                        const creditBox = document.querySelector('input[type="checkbox"][id*="credit"]');
                        if (creditBox) creditBox.checked = false;
                    } else if (this.id.includes('credit') && this.checked) {
                        const debitBox = document.querySelector('input[type="checkbox"][id*="debit"]');
                        if (debitBox) debitBox.checked = false;
                    }
                });
            });
        });

        // console.log('CheckBook Pro Complete Demo Loaded');
    </script>
</body>
</html>